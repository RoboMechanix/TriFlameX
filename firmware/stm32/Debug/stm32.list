
stm32.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000124c  08000110  08000110  00001110  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  0800135c  0800135c  00003004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  0800135c  0800135c  00003004  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  0800135c  0800135c  00003004  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  0800135c  0800135c  00003004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800135c  0800135c  0000235c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08001360  08001360  00002360  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000004  20000000  08001364  00003000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000114  20000008  08001368  00003008  2**3
                  ALLOC
 10 ._user_heap_stack 00000604  2000011c  08001368  0000311c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00003004  2**0
                  CONTENTS, READONLY
 12 .debug_info   000045da  00000000  00000000  0000302d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001183  00000000  00000000  00007607  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000518  00000000  00000000  00008790  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 000003c5  00000000  00000000  00008ca8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000018f1  00000000  00000000  0000906d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0000739b  00000000  00000000  0000a95e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00086e20  00000000  00000000  00011cf9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  00098b19  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00001304  00000000  00000000  00098b5c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000061  00000000  00000000  00099e60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000110 <__do_global_dtors_aux>:
 8000110:	b510      	push	{r4, lr}
 8000112:	4c05      	ldr	r4, [pc, #20]	@ (8000128 <__do_global_dtors_aux+0x18>)
 8000114:	7823      	ldrb	r3, [r4, #0]
 8000116:	b933      	cbnz	r3, 8000126 <__do_global_dtors_aux+0x16>
 8000118:	4b04      	ldr	r3, [pc, #16]	@ (800012c <__do_global_dtors_aux+0x1c>)
 800011a:	b113      	cbz	r3, 8000122 <__do_global_dtors_aux+0x12>
 800011c:	4804      	ldr	r0, [pc, #16]	@ (8000130 <__do_global_dtors_aux+0x20>)
 800011e:	f3af 8000 	nop.w
 8000122:	2301      	movs	r3, #1
 8000124:	7023      	strb	r3, [r4, #0]
 8000126:	bd10      	pop	{r4, pc}
 8000128:	20000008 	.word	0x20000008
 800012c:	00000000 	.word	0x00000000
 8000130:	08001344 	.word	0x08001344

08000134 <frame_dummy>:
 8000134:	b508      	push	{r3, lr}
 8000136:	4b03      	ldr	r3, [pc, #12]	@ (8000144 <frame_dummy+0x10>)
 8000138:	b11b      	cbz	r3, 8000142 <frame_dummy+0xe>
 800013a:	4903      	ldr	r1, [pc, #12]	@ (8000148 <frame_dummy+0x14>)
 800013c:	4803      	ldr	r0, [pc, #12]	@ (800014c <frame_dummy+0x18>)
 800013e:	f3af 8000 	nop.w
 8000142:	bd08      	pop	{r3, pc}
 8000144:	00000000 	.word	0x00000000
 8000148:	2000000c 	.word	0x2000000c
 800014c:	08001344 	.word	0x08001344

08000150 <__aeabi_frsub>:
 8000150:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
 8000154:	e002      	b.n	800015c <__addsf3>
 8000156:	bf00      	nop

08000158 <__aeabi_fsub>:
 8000158:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

0800015c <__addsf3>:
 800015c:	0042      	lsls	r2, r0, #1
 800015e:	bf1f      	itttt	ne
 8000160:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000164:	ea92 0f03 	teqne	r2, r3
 8000168:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 800016c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000170:	d06a      	beq.n	8000248 <__addsf3+0xec>
 8000172:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000176:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 800017a:	bfc1      	itttt	gt
 800017c:	18d2      	addgt	r2, r2, r3
 800017e:	4041      	eorgt	r1, r0
 8000180:	4048      	eorgt	r0, r1
 8000182:	4041      	eorgt	r1, r0
 8000184:	bfb8      	it	lt
 8000186:	425b      	neglt	r3, r3
 8000188:	2b19      	cmp	r3, #25
 800018a:	bf88      	it	hi
 800018c:	4770      	bxhi	lr
 800018e:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 8000192:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000196:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 800019a:	bf18      	it	ne
 800019c:	4240      	negne	r0, r0
 800019e:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80001a2:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 80001a6:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
 80001aa:	bf18      	it	ne
 80001ac:	4249      	negne	r1, r1
 80001ae:	ea92 0f03 	teq	r2, r3
 80001b2:	d03f      	beq.n	8000234 <__addsf3+0xd8>
 80001b4:	f1a2 0201 	sub.w	r2, r2, #1
 80001b8:	fa41 fc03 	asr.w	ip, r1, r3
 80001bc:	eb10 000c 	adds.w	r0, r0, ip
 80001c0:	f1c3 0320 	rsb	r3, r3, #32
 80001c4:	fa01 f103 	lsl.w	r1, r1, r3
 80001c8:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 80001cc:	d502      	bpl.n	80001d4 <__addsf3+0x78>
 80001ce:	4249      	negs	r1, r1
 80001d0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80001d4:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 80001d8:	d313      	bcc.n	8000202 <__addsf3+0xa6>
 80001da:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 80001de:	d306      	bcc.n	80001ee <__addsf3+0x92>
 80001e0:	0840      	lsrs	r0, r0, #1
 80001e2:	ea4f 0131 	mov.w	r1, r1, rrx
 80001e6:	f102 0201 	add.w	r2, r2, #1
 80001ea:	2afe      	cmp	r2, #254	@ 0xfe
 80001ec:	d251      	bcs.n	8000292 <__addsf3+0x136>
 80001ee:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 80001f2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80001f6:	bf08      	it	eq
 80001f8:	f020 0001 	biceq.w	r0, r0, #1
 80001fc:	ea40 0003 	orr.w	r0, r0, r3
 8000200:	4770      	bx	lr
 8000202:	0049      	lsls	r1, r1, #1
 8000204:	eb40 0000 	adc.w	r0, r0, r0
 8000208:	3a01      	subs	r2, #1
 800020a:	bf28      	it	cs
 800020c:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
 8000210:	d2ed      	bcs.n	80001ee <__addsf3+0x92>
 8000212:	fab0 fc80 	clz	ip, r0
 8000216:	f1ac 0c08 	sub.w	ip, ip, #8
 800021a:	ebb2 020c 	subs.w	r2, r2, ip
 800021e:	fa00 f00c 	lsl.w	r0, r0, ip
 8000222:	bfaa      	itet	ge
 8000224:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000228:	4252      	neglt	r2, r2
 800022a:	4318      	orrge	r0, r3
 800022c:	bfbc      	itt	lt
 800022e:	40d0      	lsrlt	r0, r2
 8000230:	4318      	orrlt	r0, r3
 8000232:	4770      	bx	lr
 8000234:	f092 0f00 	teq	r2, #0
 8000238:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
 800023c:	bf06      	itte	eq
 800023e:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
 8000242:	3201      	addeq	r2, #1
 8000244:	3b01      	subne	r3, #1
 8000246:	e7b5      	b.n	80001b4 <__addsf3+0x58>
 8000248:	ea4f 0341 	mov.w	r3, r1, lsl #1
 800024c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000250:	bf18      	it	ne
 8000252:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000256:	d021      	beq.n	800029c <__addsf3+0x140>
 8000258:	ea92 0f03 	teq	r2, r3
 800025c:	d004      	beq.n	8000268 <__addsf3+0x10c>
 800025e:	f092 0f00 	teq	r2, #0
 8000262:	bf08      	it	eq
 8000264:	4608      	moveq	r0, r1
 8000266:	4770      	bx	lr
 8000268:	ea90 0f01 	teq	r0, r1
 800026c:	bf1c      	itt	ne
 800026e:	2000      	movne	r0, #0
 8000270:	4770      	bxne	lr
 8000272:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
 8000276:	d104      	bne.n	8000282 <__addsf3+0x126>
 8000278:	0040      	lsls	r0, r0, #1
 800027a:	bf28      	it	cs
 800027c:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
 8000280:	4770      	bx	lr
 8000282:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
 8000286:	bf3c      	itt	cc
 8000288:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
 800028c:	4770      	bxcc	lr
 800028e:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 8000292:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
 8000296:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 800029a:	4770      	bx	lr
 800029c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80002a0:	bf16      	itet	ne
 80002a2:	4608      	movne	r0, r1
 80002a4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80002a8:	4601      	movne	r1, r0
 80002aa:	0242      	lsls	r2, r0, #9
 80002ac:	bf06      	itte	eq
 80002ae:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80002b2:	ea90 0f01 	teqeq	r0, r1
 80002b6:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
 80002ba:	4770      	bx	lr

080002bc <__aeabi_ui2f>:
 80002bc:	f04f 0300 	mov.w	r3, #0
 80002c0:	e004      	b.n	80002cc <__aeabi_i2f+0x8>
 80002c2:	bf00      	nop

080002c4 <__aeabi_i2f>:
 80002c4:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
 80002c8:	bf48      	it	mi
 80002ca:	4240      	negmi	r0, r0
 80002cc:	ea5f 0c00 	movs.w	ip, r0
 80002d0:	bf08      	it	eq
 80002d2:	4770      	bxeq	lr
 80002d4:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000
 80002d8:	4601      	mov	r1, r0
 80002da:	f04f 0000 	mov.w	r0, #0
 80002de:	e01c      	b.n	800031a <__aeabi_l2f+0x2a>

080002e0 <__aeabi_ul2f>:
 80002e0:	ea50 0201 	orrs.w	r2, r0, r1
 80002e4:	bf08      	it	eq
 80002e6:	4770      	bxeq	lr
 80002e8:	f04f 0300 	mov.w	r3, #0
 80002ec:	e00a      	b.n	8000304 <__aeabi_l2f+0x14>
 80002ee:	bf00      	nop

080002f0 <__aeabi_l2f>:
 80002f0:	ea50 0201 	orrs.w	r2, r0, r1
 80002f4:	bf08      	it	eq
 80002f6:	4770      	bxeq	lr
 80002f8:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
 80002fc:	d502      	bpl.n	8000304 <__aeabi_l2f+0x14>
 80002fe:	4240      	negs	r0, r0
 8000300:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000304:	ea5f 0c01 	movs.w	ip, r1
 8000308:	bf02      	ittt	eq
 800030a:	4684      	moveq	ip, r0
 800030c:	4601      	moveq	r1, r0
 800030e:	2000      	moveq	r0, #0
 8000310:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
 8000314:	bf08      	it	eq
 8000316:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
 800031a:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
 800031e:	fabc f28c 	clz	r2, ip
 8000322:	3a08      	subs	r2, #8
 8000324:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000328:	db10      	blt.n	800034c <__aeabi_l2f+0x5c>
 800032a:	fa01 fc02 	lsl.w	ip, r1, r2
 800032e:	4463      	add	r3, ip
 8000330:	fa00 fc02 	lsl.w	ip, r0, r2
 8000334:	f1c2 0220 	rsb	r2, r2, #32
 8000338:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800033c:	fa20 f202 	lsr.w	r2, r0, r2
 8000340:	eb43 0002 	adc.w	r0, r3, r2
 8000344:	bf08      	it	eq
 8000346:	f020 0001 	biceq.w	r0, r0, #1
 800034a:	4770      	bx	lr
 800034c:	f102 0220 	add.w	r2, r2, #32
 8000350:	fa01 fc02 	lsl.w	ip, r1, r2
 8000354:	f1c2 0220 	rsb	r2, r2, #32
 8000358:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 800035c:	fa21 f202 	lsr.w	r2, r1, r2
 8000360:	eb43 0002 	adc.w	r0, r3, r2
 8000364:	bf08      	it	eq
 8000366:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 800036a:	4770      	bx	lr

0800036c <__aeabi_fmul>:
 800036c:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000370:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000374:	bf1e      	ittt	ne
 8000376:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 800037a:	ea92 0f0c 	teqne	r2, ip
 800037e:	ea93 0f0c 	teqne	r3, ip
 8000382:	d06f      	beq.n	8000464 <__aeabi_fmul+0xf8>
 8000384:	441a      	add	r2, r3
 8000386:	ea80 0c01 	eor.w	ip, r0, r1
 800038a:	0240      	lsls	r0, r0, #9
 800038c:	bf18      	it	ne
 800038e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000392:	d01e      	beq.n	80003d2 <__aeabi_fmul+0x66>
 8000394:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8000398:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 800039c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80003a0:	fba0 3101 	umull	r3, r1, r0, r1
 80003a4:	f00c 4000 	and.w	r0, ip, #2147483648	@ 0x80000000
 80003a8:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
 80003ac:	bf3e      	ittt	cc
 80003ae:	0049      	lslcc	r1, r1, #1
 80003b0:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80003b4:	005b      	lslcc	r3, r3, #1
 80003b6:	ea40 0001 	orr.w	r0, r0, r1
 80003ba:	f162 027f 	sbc.w	r2, r2, #127	@ 0x7f
 80003be:	2afd      	cmp	r2, #253	@ 0xfd
 80003c0:	d81d      	bhi.n	80003fe <__aeabi_fmul+0x92>
 80003c2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80003c6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80003ca:	bf08      	it	eq
 80003cc:	f020 0001 	biceq.w	r0, r0, #1
 80003d0:	4770      	bx	lr
 80003d2:	f090 0f00 	teq	r0, #0
 80003d6:	f00c 4c00 	and.w	ip, ip, #2147483648	@ 0x80000000
 80003da:	bf08      	it	eq
 80003dc:	0249      	lsleq	r1, r1, #9
 80003de:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80003e2:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80003e6:	3a7f      	subs	r2, #127	@ 0x7f
 80003e8:	bfc2      	ittt	gt
 80003ea:	f1d2 03ff 	rsbsgt	r3, r2, #255	@ 0xff
 80003ee:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80003f2:	4770      	bxgt	lr
 80003f4:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80003f8:	f04f 0300 	mov.w	r3, #0
 80003fc:	3a01      	subs	r2, #1
 80003fe:	dc5d      	bgt.n	80004bc <__aeabi_fmul+0x150>
 8000400:	f112 0f19 	cmn.w	r2, #25
 8000404:	bfdc      	itt	le
 8000406:	f000 4000 	andle.w	r0, r0, #2147483648	@ 0x80000000
 800040a:	4770      	bxle	lr
 800040c:	f1c2 0200 	rsb	r2, r2, #0
 8000410:	0041      	lsls	r1, r0, #1
 8000412:	fa21 f102 	lsr.w	r1, r1, r2
 8000416:	f1c2 0220 	rsb	r2, r2, #32
 800041a:	fa00 fc02 	lsl.w	ip, r0, r2
 800041e:	ea5f 0031 	movs.w	r0, r1, rrx
 8000422:	f140 0000 	adc.w	r0, r0, #0
 8000426:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 800042a:	bf08      	it	eq
 800042c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000430:	4770      	bx	lr
 8000432:	f092 0f00 	teq	r2, #0
 8000436:	f000 4c00 	and.w	ip, r0, #2147483648	@ 0x80000000
 800043a:	bf02      	ittt	eq
 800043c:	0040      	lsleq	r0, r0, #1
 800043e:	f410 0f00 	tsteq.w	r0, #8388608	@ 0x800000
 8000442:	3a01      	subeq	r2, #1
 8000444:	d0f9      	beq.n	800043a <__aeabi_fmul+0xce>
 8000446:	ea40 000c 	orr.w	r0, r0, ip
 800044a:	f093 0f00 	teq	r3, #0
 800044e:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000452:	bf02      	ittt	eq
 8000454:	0049      	lsleq	r1, r1, #1
 8000456:	f411 0f00 	tsteq.w	r1, #8388608	@ 0x800000
 800045a:	3b01      	subeq	r3, #1
 800045c:	d0f9      	beq.n	8000452 <__aeabi_fmul+0xe6>
 800045e:	ea41 010c 	orr.w	r1, r1, ip
 8000462:	e78f      	b.n	8000384 <__aeabi_fmul+0x18>
 8000464:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000468:	ea92 0f0c 	teq	r2, ip
 800046c:	bf18      	it	ne
 800046e:	ea93 0f0c 	teqne	r3, ip
 8000472:	d00a      	beq.n	800048a <__aeabi_fmul+0x11e>
 8000474:	f030 4c00 	bics.w	ip, r0, #2147483648	@ 0x80000000
 8000478:	bf18      	it	ne
 800047a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	@ 0x80000000
 800047e:	d1d8      	bne.n	8000432 <__aeabi_fmul+0xc6>
 8000480:	ea80 0001 	eor.w	r0, r0, r1
 8000484:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
 8000488:	4770      	bx	lr
 800048a:	f090 0f00 	teq	r0, #0
 800048e:	bf17      	itett	ne
 8000490:	f090 4f00 	teqne	r0, #2147483648	@ 0x80000000
 8000494:	4608      	moveq	r0, r1
 8000496:	f091 0f00 	teqne	r1, #0
 800049a:	f091 4f00 	teqne	r1, #2147483648	@ 0x80000000
 800049e:	d014      	beq.n	80004ca <__aeabi_fmul+0x15e>
 80004a0:	ea92 0f0c 	teq	r2, ip
 80004a4:	d101      	bne.n	80004aa <__aeabi_fmul+0x13e>
 80004a6:	0242      	lsls	r2, r0, #9
 80004a8:	d10f      	bne.n	80004ca <__aeabi_fmul+0x15e>
 80004aa:	ea93 0f0c 	teq	r3, ip
 80004ae:	d103      	bne.n	80004b8 <__aeabi_fmul+0x14c>
 80004b0:	024b      	lsls	r3, r1, #9
 80004b2:	bf18      	it	ne
 80004b4:	4608      	movne	r0, r1
 80004b6:	d108      	bne.n	80004ca <__aeabi_fmul+0x15e>
 80004b8:	ea80 0001 	eor.w	r0, r0, r1
 80004bc:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
 80004c0:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 80004c4:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80004c8:	4770      	bx	lr
 80004ca:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 80004ce:	f440 0040 	orr.w	r0, r0, #12582912	@ 0xc00000
 80004d2:	4770      	bx	lr

080004d4 <__aeabi_fdiv>:
 80004d4:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80004d8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80004dc:	bf1e      	ittt	ne
 80004de:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80004e2:	ea92 0f0c 	teqne	r2, ip
 80004e6:	ea93 0f0c 	teqne	r3, ip
 80004ea:	d069      	beq.n	80005c0 <__aeabi_fdiv+0xec>
 80004ec:	eba2 0203 	sub.w	r2, r2, r3
 80004f0:	ea80 0c01 	eor.w	ip, r0, r1
 80004f4:	0249      	lsls	r1, r1, #9
 80004f6:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80004fa:	d037      	beq.n	800056c <__aeabi_fdiv+0x98>
 80004fc:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8000500:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000504:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000508:	f00c 4000 	and.w	r0, ip, #2147483648	@ 0x80000000
 800050c:	428b      	cmp	r3, r1
 800050e:	bf38      	it	cc
 8000510:	005b      	lslcc	r3, r3, #1
 8000512:	f142 027d 	adc.w	r2, r2, #125	@ 0x7d
 8000516:	f44f 0c00 	mov.w	ip, #8388608	@ 0x800000
 800051a:	428b      	cmp	r3, r1
 800051c:	bf24      	itt	cs
 800051e:	1a5b      	subcs	r3, r3, r1
 8000520:	ea40 000c 	orrcs.w	r0, r0, ip
 8000524:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000528:	bf24      	itt	cs
 800052a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 800052e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000532:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000536:	bf24      	itt	cs
 8000538:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 800053c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000540:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000544:	bf24      	itt	cs
 8000546:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 800054a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800054e:	011b      	lsls	r3, r3, #4
 8000550:	bf18      	it	ne
 8000552:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000556:	d1e0      	bne.n	800051a <__aeabi_fdiv+0x46>
 8000558:	2afd      	cmp	r2, #253	@ 0xfd
 800055a:	f63f af50 	bhi.w	80003fe <__aeabi_fmul+0x92>
 800055e:	428b      	cmp	r3, r1
 8000560:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000564:	bf08      	it	eq
 8000566:	f020 0001 	biceq.w	r0, r0, #1
 800056a:	4770      	bx	lr
 800056c:	f00c 4c00 	and.w	ip, ip, #2147483648	@ 0x80000000
 8000570:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000574:	327f      	adds	r2, #127	@ 0x7f
 8000576:	bfc2      	ittt	gt
 8000578:	f1d2 03ff 	rsbsgt	r3, r2, #255	@ 0xff
 800057c:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000580:	4770      	bxgt	lr
 8000582:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000586:	f04f 0300 	mov.w	r3, #0
 800058a:	3a01      	subs	r2, #1
 800058c:	e737      	b.n	80003fe <__aeabi_fmul+0x92>
 800058e:	f092 0f00 	teq	r2, #0
 8000592:	f000 4c00 	and.w	ip, r0, #2147483648	@ 0x80000000
 8000596:	bf02      	ittt	eq
 8000598:	0040      	lsleq	r0, r0, #1
 800059a:	f410 0f00 	tsteq.w	r0, #8388608	@ 0x800000
 800059e:	3a01      	subeq	r2, #1
 80005a0:	d0f9      	beq.n	8000596 <__aeabi_fdiv+0xc2>
 80005a2:	ea40 000c 	orr.w	r0, r0, ip
 80005a6:	f093 0f00 	teq	r3, #0
 80005aa:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 80005ae:	bf02      	ittt	eq
 80005b0:	0049      	lsleq	r1, r1, #1
 80005b2:	f411 0f00 	tsteq.w	r1, #8388608	@ 0x800000
 80005b6:	3b01      	subeq	r3, #1
 80005b8:	d0f9      	beq.n	80005ae <__aeabi_fdiv+0xda>
 80005ba:	ea41 010c 	orr.w	r1, r1, ip
 80005be:	e795      	b.n	80004ec <__aeabi_fdiv+0x18>
 80005c0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80005c4:	ea92 0f0c 	teq	r2, ip
 80005c8:	d108      	bne.n	80005dc <__aeabi_fdiv+0x108>
 80005ca:	0242      	lsls	r2, r0, #9
 80005cc:	f47f af7d 	bne.w	80004ca <__aeabi_fmul+0x15e>
 80005d0:	ea93 0f0c 	teq	r3, ip
 80005d4:	f47f af70 	bne.w	80004b8 <__aeabi_fmul+0x14c>
 80005d8:	4608      	mov	r0, r1
 80005da:	e776      	b.n	80004ca <__aeabi_fmul+0x15e>
 80005dc:	ea93 0f0c 	teq	r3, ip
 80005e0:	d104      	bne.n	80005ec <__aeabi_fdiv+0x118>
 80005e2:	024b      	lsls	r3, r1, #9
 80005e4:	f43f af4c 	beq.w	8000480 <__aeabi_fmul+0x114>
 80005e8:	4608      	mov	r0, r1
 80005ea:	e76e      	b.n	80004ca <__aeabi_fmul+0x15e>
 80005ec:	f030 4c00 	bics.w	ip, r0, #2147483648	@ 0x80000000
 80005f0:	bf18      	it	ne
 80005f2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	@ 0x80000000
 80005f6:	d1ca      	bne.n	800058e <__aeabi_fdiv+0xba>
 80005f8:	f030 4200 	bics.w	r2, r0, #2147483648	@ 0x80000000
 80005fc:	f47f af5c 	bne.w	80004b8 <__aeabi_fmul+0x14c>
 8000600:	f031 4300 	bics.w	r3, r1, #2147483648	@ 0x80000000
 8000604:	f47f af3c 	bne.w	8000480 <__aeabi_fmul+0x114>
 8000608:	e75f      	b.n	80004ca <__aeabi_fmul+0x15e>
 800060a:	bf00      	nop

0800060c <__aeabi_f2uiz>:
 800060c:	0042      	lsls	r2, r0, #1
 800060e:	d20e      	bcs.n	800062e <__aeabi_f2uiz+0x22>
 8000610:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
 8000614:	d30b      	bcc.n	800062e <__aeabi_f2uiz+0x22>
 8000616:	f04f 039e 	mov.w	r3, #158	@ 0x9e
 800061a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 800061e:	d409      	bmi.n	8000634 <__aeabi_f2uiz+0x28>
 8000620:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000624:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000628:	fa23 f002 	lsr.w	r0, r3, r2
 800062c:	4770      	bx	lr
 800062e:	f04f 0000 	mov.w	r0, #0
 8000632:	4770      	bx	lr
 8000634:	f112 0f61 	cmn.w	r2, #97	@ 0x61
 8000638:	d101      	bne.n	800063e <__aeabi_f2uiz+0x32>
 800063a:	0242      	lsls	r2, r0, #9
 800063c:	d102      	bne.n	8000644 <__aeabi_f2uiz+0x38>
 800063e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8000642:	4770      	bx	lr
 8000644:	f04f 0000 	mov.w	r0, #0
 8000648:	4770      	bx	lr
 800064a:	bf00      	nop

0800064c <main>:
void turnON(char i);
void turnOFF(char i);
char y =0;
uint16_t distance;

int main(void) {
 800064c:	b580      	push	{r7, lr}
 800064e:	b084      	sub	sp, #16
 8000650:	af00      	add	r7, sp, #0

				RCC->APB2ENR |= 0xFFFFF;
 8000652:	4b1c      	ldr	r3, [pc, #112]	@ (80006c4 <main+0x78>)
 8000654:	699b      	ldr	r3, [r3, #24]
 8000656:	4a1b      	ldr	r2, [pc, #108]	@ (80006c4 <main+0x78>)
 8000658:	ea6f 5313 	mvn.w	r3, r3, lsr #20
 800065c:	ea6f 5303 	mvn.w	r3, r3, lsl #20
 8000660:	6193      	str	r3, [r2, #24]
				GPIOB -> CRH = 0x44442244;
 8000662:	4b19      	ldr	r3, [pc, #100]	@ (80006c8 <main+0x7c>)
 8000664:	4a19      	ldr	r2, [pc, #100]	@ (80006cc <main+0x80>)
 8000666:	605a      	str	r2, [r3, #4]
				GPIOA -> CRL = 0x24444444;
 8000668:	4b19      	ldr	r3, [pc, #100]	@ (80006d0 <main+0x84>)
 800066a:	4a1a      	ldr	r2, [pc, #104]	@ (80006d4 <main+0x88>)
 800066c:	601a      	str	r2, [r3, #0]

	while (1){
			//turnON(0);
			UART_init(1,BAUDRATE);
 800066e:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
 8000672:	2001      	movs	r0, #1
 8000674:	f000 faa0 	bl	8000bb8 <UART_init>
			while (1) {
				UARTMessage msg;
				do {
				    msg = UART_receive_message(1);
 8000678:	1d3b      	adds	r3, r7, #4
 800067a:	2101      	movs	r1, #1
 800067c:	4618      	mov	r0, r3
 800067e:	f000 fb5d 	bl	8000d3c <UART_receive_message>
				} while (msg.type == MSG_NONE);
 8000682:	793b      	ldrb	r3, [r7, #4]
 8000684:	2b00      	cmp	r3, #0
 8000686:	d0f7      	beq.n	8000678 <main+0x2c>
				    switch (msg.type) {
 8000688:	793b      	ldrb	r3, [r7, #4]
 800068a:	2b05      	cmp	r3, #5
 800068c:	d118      	bne.n	80006c0 <main+0x74>
				        //turnON(0);
				        //turnOFF(1);

				        }

				        distance = msg.distance;
 800068e:	88fa      	ldrh	r2, [r7, #6]
 8000690:	4b11      	ldr	r3, [pc, #68]	@ (80006d8 <main+0x8c>)
 8000692:	801a      	strh	r2, [r3, #0]
				        if (distance < 70 && distance >= 0){
 8000694:	4b10      	ldr	r3, [pc, #64]	@ (80006d8 <main+0x8c>)
 8000696:	881b      	ldrh	r3, [r3, #0]
 8000698:	2b45      	cmp	r3, #69	@ 0x45
 800069a:	d806      	bhi.n	80006aa <main+0x5e>
				        	turnON(1);
 800069c:	2001      	movs	r0, #1
 800069e:	f000 f81f 	bl	80006e0 <turnON>
				        	turnOFF(0);
 80006a2:	2000      	movs	r0, #0
 80006a4:	f000 f83c 	bl	8000720 <turnOFF>
 80006a8:	e005      	b.n	80006b6 <main+0x6a>
				        }
				        else {
				        	turnON(0);
 80006aa:	2000      	movs	r0, #0
 80006ac:	f000 f818 	bl	80006e0 <turnON>
				        	turnOFF(1);
 80006b0:	2001      	movs	r0, #1
 80006b2:	f000 f835 	bl	8000720 <turnOFF>
				        }
				        angle = msg.angle;
 80006b6:	68fb      	ldr	r3, [r7, #12]
 80006b8:	b29a      	uxth	r2, r3
 80006ba:	4b08      	ldr	r3, [pc, #32]	@ (80006dc <main+0x90>)
 80006bc:	801a      	strh	r2, [r3, #0]
				            break;
 80006be:	e000      	b.n	80006c2 <main+0x76>
				        default:
				            break;
 80006c0:	bf00      	nop
			while (1) {
 80006c2:	e7d9      	b.n	8000678 <main+0x2c>
 80006c4:	40021000 	.word	0x40021000
 80006c8:	40010c00 	.word	0x40010c00
 80006cc:	44442244 	.word	0x44442244
 80006d0:	40010800 	.word	0x40010800
 80006d4:	24444444 	.word	0x24444444
 80006d8:	20000026 	.word	0x20000026
 80006dc:	20000024 	.word	0x20000024

080006e0 <turnON>:
				    }
			}
	}
}

void turnON(char i){
 80006e0:	b480      	push	{r7}
 80006e2:	b083      	sub	sp, #12
 80006e4:	af00      	add	r7, sp, #0
 80006e6:	4603      	mov	r3, r0
 80006e8:	71fb      	strb	r3, [r7, #7]
	switch (i){
 80006ea:	79fb      	ldrb	r3, [r7, #7]
 80006ec:	2b00      	cmp	r3, #0
 80006ee:	d002      	beq.n	80006f6 <turnON+0x16>
 80006f0:	2b01      	cmp	r3, #1
 80006f2:	d007      	beq.n	8000704 <turnON+0x24>
		case 0 : GPIOB ->ODR |= (1<<10); return;
		case 1 : GPIOB ->ODR |= (1<<11); return;
		default : return;
 80006f4:	e00d      	b.n	8000712 <turnON+0x32>
		case 0 : GPIOB ->ODR |= (1<<10); return;
 80006f6:	4b09      	ldr	r3, [pc, #36]	@ (800071c <turnON+0x3c>)
 80006f8:	68db      	ldr	r3, [r3, #12]
 80006fa:	4a08      	ldr	r2, [pc, #32]	@ (800071c <turnON+0x3c>)
 80006fc:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8000700:	60d3      	str	r3, [r2, #12]
 8000702:	e006      	b.n	8000712 <turnON+0x32>
		case 1 : GPIOB ->ODR |= (1<<11); return;
 8000704:	4b05      	ldr	r3, [pc, #20]	@ (800071c <turnON+0x3c>)
 8000706:	68db      	ldr	r3, [r3, #12]
 8000708:	4a04      	ldr	r2, [pc, #16]	@ (800071c <turnON+0x3c>)
 800070a:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 800070e:	60d3      	str	r3, [r2, #12]
 8000710:	bf00      	nop
		}
}
 8000712:	370c      	adds	r7, #12
 8000714:	46bd      	mov	sp, r7
 8000716:	bc80      	pop	{r7}
 8000718:	4770      	bx	lr
 800071a:	bf00      	nop
 800071c:	40010c00 	.word	0x40010c00

08000720 <turnOFF>:

void turnOFF(char i){
 8000720:	b480      	push	{r7}
 8000722:	b083      	sub	sp, #12
 8000724:	af00      	add	r7, sp, #0
 8000726:	4603      	mov	r3, r0
 8000728:	71fb      	strb	r3, [r7, #7]
	switch (i){
 800072a:	79fb      	ldrb	r3, [r7, #7]
 800072c:	2b00      	cmp	r3, #0
 800072e:	d002      	beq.n	8000736 <turnOFF+0x16>
 8000730:	2b01      	cmp	r3, #1
 8000732:	d007      	beq.n	8000744 <turnOFF+0x24>
		case 0 : GPIOB ->ODR &= ~(1<<10); return;
		case 1 : GPIOB ->ODR &= ~(1<<11); return;
		default : return;
 8000734:	e00d      	b.n	8000752 <turnOFF+0x32>
		case 0 : GPIOB ->ODR &= ~(1<<10); return;
 8000736:	4b09      	ldr	r3, [pc, #36]	@ (800075c <turnOFF+0x3c>)
 8000738:	68db      	ldr	r3, [r3, #12]
 800073a:	4a08      	ldr	r2, [pc, #32]	@ (800075c <turnOFF+0x3c>)
 800073c:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8000740:	60d3      	str	r3, [r2, #12]
 8000742:	e006      	b.n	8000752 <turnOFF+0x32>
		case 1 : GPIOB ->ODR &= ~(1<<11); return;
 8000744:	4b05      	ldr	r3, [pc, #20]	@ (800075c <turnOFF+0x3c>)
 8000746:	68db      	ldr	r3, [r3, #12]
 8000748:	4a04      	ldr	r2, [pc, #16]	@ (800075c <turnOFF+0x3c>)
 800074a:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 800074e:	60d3      	str	r3, [r2, #12]
 8000750:	bf00      	nop
		}
}
 8000752:	370c      	adds	r7, #12
 8000754:	46bd      	mov	sp, r7
 8000756:	bc80      	pop	{r7}
 8000758:	4770      	bx	lr
 800075a:	bf00      	nop
 800075c:	40010c00 	.word	0x40010c00

08000760 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8000760:	b480      	push	{r7}
 8000762:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8000764:	bf00      	nop
 8000766:	e7fd      	b.n	8000764 <NMI_Handler+0x4>

08000768 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000768:	b480      	push	{r7}
 800076a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800076c:	bf00      	nop
 800076e:	e7fd      	b.n	800076c <HardFault_Handler+0x4>

08000770 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000770:	b480      	push	{r7}
 8000772:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000774:	bf00      	nop
 8000776:	e7fd      	b.n	8000774 <MemManage_Handler+0x4>

08000778 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000778:	b480      	push	{r7}
 800077a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800077c:	bf00      	nop
 800077e:	e7fd      	b.n	800077c <BusFault_Handler+0x4>

08000780 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000780:	b480      	push	{r7}
 8000782:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000784:	bf00      	nop
 8000786:	e7fd      	b.n	8000784 <UsageFault_Handler+0x4>

08000788 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000788:	b480      	push	{r7}
 800078a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800078c:	bf00      	nop
 800078e:	46bd      	mov	sp, r7
 8000790:	bc80      	pop	{r7}
 8000792:	4770      	bx	lr

08000794 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000794:	b580      	push	{r7, lr}
 8000796:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000798:	f000 f836 	bl	8000808 <HAL_IncTick>
#if (INCLUDE_xTaskGetSchedulerState == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 800079c:	f000 fd32 	bl	8001204 <xTaskGetSchedulerState>
 80007a0:	4603      	mov	r3, r0
 80007a2:	2b01      	cmp	r3, #1
 80007a4:	d001      	beq.n	80007aa <SysTick_Handler+0x16>
  {
#endif /* INCLUDE_xTaskGetSchedulerState */
  xPortSysTickHandler();
 80007a6:	f000 fd87 	bl	80012b8 <xPortSysTickHandler>
  }
#endif /* INCLUDE_xTaskGetSchedulerState */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80007aa:	bf00      	nop
 80007ac:	bd80      	pop	{r7, pc}

080007ae <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 80007ae:	b480      	push	{r7}
 80007b0:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80007b2:	bf00      	nop
 80007b4:	46bd      	mov	sp, r7
 80007b6:	bc80      	pop	{r7}
 80007b8:	4770      	bx	lr
	...

080007bc <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Call the clock system initialization function.*/
    bl  SystemInit
 80007bc:	f7ff fff7 	bl	80007ae <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80007c0:	480b      	ldr	r0, [pc, #44]	@ (80007f0 <LoopFillZerobss+0xe>)
  ldr r1, =_edata
 80007c2:	490c      	ldr	r1, [pc, #48]	@ (80007f4 <LoopFillZerobss+0x12>)
  ldr r2, =_sidata
 80007c4:	4a0c      	ldr	r2, [pc, #48]	@ (80007f8 <LoopFillZerobss+0x16>)
  movs r3, #0
 80007c6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80007c8:	e002      	b.n	80007d0 <LoopCopyDataInit>

080007ca <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80007ca:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80007cc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80007ce:	3304      	adds	r3, #4

080007d0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80007d0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80007d2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80007d4:	d3f9      	bcc.n	80007ca <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80007d6:	4a09      	ldr	r2, [pc, #36]	@ (80007fc <LoopFillZerobss+0x1a>)
  ldr r4, =_ebss
 80007d8:	4c09      	ldr	r4, [pc, #36]	@ (8000800 <LoopFillZerobss+0x1e>)
  movs r3, #0
 80007da:	2300      	movs	r3, #0
  b LoopFillZerobss
 80007dc:	e001      	b.n	80007e2 <LoopFillZerobss>

080007de <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80007de:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80007e0:	3204      	adds	r2, #4

080007e2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80007e2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80007e4:	d3fb      	bcc.n	80007de <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 80007e6:	f000 fd89 	bl	80012fc <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80007ea:	f7ff ff2f 	bl	800064c <main>
  bx lr
 80007ee:	4770      	bx	lr
  ldr r0, =_sdata
 80007f0:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80007f4:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 80007f8:	08001364 	.word	0x08001364
  ldr r2, =_sbss
 80007fc:	20000008 	.word	0x20000008
  ldr r4, =_ebss
 8000800:	2000011c 	.word	0x2000011c

08000804 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000804:	e7fe      	b.n	8000804 <ADC1_2_IRQHandler>
	...

08000808 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000808:	b480      	push	{r7}
 800080a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800080c:	4b05      	ldr	r3, [pc, #20]	@ (8000824 <HAL_IncTick+0x1c>)
 800080e:	781b      	ldrb	r3, [r3, #0]
 8000810:	461a      	mov	r2, r3
 8000812:	4b05      	ldr	r3, [pc, #20]	@ (8000828 <HAL_IncTick+0x20>)
 8000814:	681b      	ldr	r3, [r3, #0]
 8000816:	4413      	add	r3, r2
 8000818:	4a03      	ldr	r2, [pc, #12]	@ (8000828 <HAL_IncTick+0x20>)
 800081a:	6013      	str	r3, [r2, #0]
}
 800081c:	bf00      	nop
 800081e:	46bd      	mov	sp, r7
 8000820:	bc80      	pop	{r7}
 8000822:	4770      	bx	lr
 8000824:	20000000 	.word	0x20000000
 8000828:	20000028 	.word	0x20000028

0800082c <GPIO_pinMode>:
#include "GPIO_interface.h"

void GPIO_pinMode(GPIO_TypeDef *GPIOX, uint8_t pinNumber, GPIO_MODE mode){
 800082c:	b480      	push	{r7}
 800082e:	b085      	sub	sp, #20
 8000830:	af00      	add	r7, sp, #0
 8000832:	6078      	str	r0, [r7, #4]
 8000834:	460b      	mov	r3, r1
 8000836:	70fb      	strb	r3, [r7, #3]
 8000838:	4613      	mov	r3, r2
 800083a:	70bb      	strb	r3, [r7, #2]
	if (pinNumber < 0 || pinNumber > 15){
 800083c:	78fb      	ldrb	r3, [r7, #3]
 800083e:	2b0f      	cmp	r3, #15
 8000840:	f200 8099 	bhi.w	8000976 <GPIO_pinMode+0x14a>
		return;
	}
	// Initialize the clock of port x
    if (GPIOX == GPIOA) {
 8000844:	687b      	ldr	r3, [r7, #4]
 8000846:	4a4e      	ldr	r2, [pc, #312]	@ (8000980 <GPIO_pinMode+0x154>)
 8000848:	4293      	cmp	r3, r2
 800084a:	d106      	bne.n	800085a <GPIO_pinMode+0x2e>
		SET_BIT(RCC->APB2ENR, 2);
 800084c:	4b4d      	ldr	r3, [pc, #308]	@ (8000984 <GPIO_pinMode+0x158>)
 800084e:	699b      	ldr	r3, [r3, #24]
 8000850:	4a4c      	ldr	r2, [pc, #304]	@ (8000984 <GPIO_pinMode+0x158>)
 8000852:	f043 0304 	orr.w	r3, r3, #4
 8000856:	6193      	str	r3, [r2, #24]
 8000858:	e014      	b.n	8000884 <GPIO_pinMode+0x58>
    } else if (GPIOX == GPIOB) {
 800085a:	687b      	ldr	r3, [r7, #4]
 800085c:	4a4a      	ldr	r2, [pc, #296]	@ (8000988 <GPIO_pinMode+0x15c>)
 800085e:	4293      	cmp	r3, r2
 8000860:	d106      	bne.n	8000870 <GPIO_pinMode+0x44>
		SET_BIT(RCC->APB2ENR, 3);
 8000862:	4b48      	ldr	r3, [pc, #288]	@ (8000984 <GPIO_pinMode+0x158>)
 8000864:	699b      	ldr	r3, [r3, #24]
 8000866:	4a47      	ldr	r2, [pc, #284]	@ (8000984 <GPIO_pinMode+0x158>)
 8000868:	f043 0308 	orr.w	r3, r3, #8
 800086c:	6193      	str	r3, [r2, #24]
 800086e:	e009      	b.n	8000884 <GPIO_pinMode+0x58>
    } else if (GPIOX == GPIOC) {
 8000870:	687b      	ldr	r3, [r7, #4]
 8000872:	4a46      	ldr	r2, [pc, #280]	@ (800098c <GPIO_pinMode+0x160>)
 8000874:	4293      	cmp	r3, r2
 8000876:	d105      	bne.n	8000884 <GPIO_pinMode+0x58>
		SET_BIT(RCC->APB2ENR, 4);
 8000878:	4b42      	ldr	r3, [pc, #264]	@ (8000984 <GPIO_pinMode+0x158>)
 800087a:	699b      	ldr	r3, [r3, #24]
 800087c:	4a41      	ldr	r2, [pc, #260]	@ (8000984 <GPIO_pinMode+0x158>)
 800087e:	f043 0310 	orr.w	r3, r3, #16
 8000882:	6193      	str	r3, [r2, #24]
    }
	volatile uint8_t pinIndex = pinNumber % 8;
 8000884:	78fb      	ldrb	r3, [r7, #3]
 8000886:	f003 0307 	and.w	r3, r3, #7
 800088a:	b2db      	uxtb	r3, r3
 800088c:	72fb      	strb	r3, [r7, #11]

	volatile uint32_t *CRX;
	if (pinNumber < 8 && pinNumber >= 0){
 800088e:	78fb      	ldrb	r3, [r7, #3]
 8000890:	2b07      	cmp	r3, #7
 8000892:	d802      	bhi.n	800089a <GPIO_pinMode+0x6e>
		CRX = &GPIOX->CRL;
 8000894:	687b      	ldr	r3, [r7, #4]
 8000896:	60fb      	str	r3, [r7, #12]
 8000898:	e008      	b.n	80008ac <GPIO_pinMode+0x80>
	}else if(pinNumber >= 8 && pinNumber < 16){
 800089a:	78fb      	ldrb	r3, [r7, #3]
 800089c:	2b07      	cmp	r3, #7
 800089e:	d905      	bls.n	80008ac <GPIO_pinMode+0x80>
 80008a0:	78fb      	ldrb	r3, [r7, #3]
 80008a2:	2b0f      	cmp	r3, #15
 80008a4:	d802      	bhi.n	80008ac <GPIO_pinMode+0x80>
		CRX = &GPIOX->CRH;
 80008a6:	687b      	ldr	r3, [r7, #4]
 80008a8:	3304      	adds	r3, #4
 80008aa:	60fb      	str	r3, [r7, #12]
	}
	// Zero the CRX register's specific pin mode not the whole register
	*CRX &= ~(0xF << (4*(pinIndex)));
 80008ac:	7afb      	ldrb	r3, [r7, #11]
 80008ae:	b2db      	uxtb	r3, r3
 80008b0:	009b      	lsls	r3, r3, #2
 80008b2:	220f      	movs	r2, #15
 80008b4:	fa02 f303 	lsl.w	r3, r2, r3
 80008b8:	43da      	mvns	r2, r3
 80008ba:	68fb      	ldr	r3, [r7, #12]
 80008bc:	681b      	ldr	r3, [r3, #0]
 80008be:	401a      	ands	r2, r3
 80008c0:	68fb      	ldr	r3, [r7, #12]
 80008c2:	601a      	str	r2, [r3, #0]
	if (mode == OUTPUT){
 80008c4:	78bb      	ldrb	r3, [r7, #2]
 80008c6:	2b03      	cmp	r3, #3
 80008c8:	d10a      	bne.n	80008e0 <GPIO_pinMode+0xb4>
		*CRX |= (0x2 << (4*(pinIndex)));
 80008ca:	7afb      	ldrb	r3, [r7, #11]
 80008cc:	b2db      	uxtb	r3, r3
 80008ce:	009b      	lsls	r3, r3, #2
 80008d0:	2202      	movs	r2, #2
 80008d2:	409a      	lsls	r2, r3
 80008d4:	68fb      	ldr	r3, [r7, #12]
 80008d6:	681b      	ldr	r3, [r3, #0]
 80008d8:	431a      	orrs	r2, r3
 80008da:	68fb      	ldr	r3, [r7, #12]
 80008dc:	601a      	str	r2, [r3, #0]
 80008de:	e04b      	b.n	8000978 <GPIO_pinMode+0x14c>
	}else if (mode == INPUT_FLOAT){
 80008e0:	78bb      	ldrb	r3, [r7, #2]
 80008e2:	2b02      	cmp	r3, #2
 80008e4:	d10a      	bne.n	80008fc <GPIO_pinMode+0xd0>
		*CRX |= (0x4 << (4*(pinIndex)));
 80008e6:	7afb      	ldrb	r3, [r7, #11]
 80008e8:	b2db      	uxtb	r3, r3
 80008ea:	009b      	lsls	r3, r3, #2
 80008ec:	2204      	movs	r2, #4
 80008ee:	409a      	lsls	r2, r3
 80008f0:	68fb      	ldr	r3, [r7, #12]
 80008f2:	681b      	ldr	r3, [r3, #0]
 80008f4:	431a      	orrs	r2, r3
 80008f6:	68fb      	ldr	r3, [r7, #12]
 80008f8:	601a      	str	r2, [r3, #0]
 80008fa:	e03d      	b.n	8000978 <GPIO_pinMode+0x14c>
	}else if (mode == INPUT_PULLUP){
 80008fc:	78bb      	ldrb	r3, [r7, #2]
 80008fe:	2b00      	cmp	r3, #0
 8000900:	d113      	bne.n	800092a <GPIO_pinMode+0xfe>
		*CRX |= (0x8 << (4*(pinIndex)));
 8000902:	7afb      	ldrb	r3, [r7, #11]
 8000904:	b2db      	uxtb	r3, r3
 8000906:	009b      	lsls	r3, r3, #2
 8000908:	2208      	movs	r2, #8
 800090a:	409a      	lsls	r2, r3
 800090c:	68fb      	ldr	r3, [r7, #12]
 800090e:	681b      	ldr	r3, [r3, #0]
 8000910:	431a      	orrs	r2, r3
 8000912:	68fb      	ldr	r3, [r7, #12]
 8000914:	601a      	str	r2, [r3, #0]
		SET_BIT(GPIOX->ODR, pinNumber);
 8000916:	687b      	ldr	r3, [r7, #4]
 8000918:	68db      	ldr	r3, [r3, #12]
 800091a:	78fa      	ldrb	r2, [r7, #3]
 800091c:	2101      	movs	r1, #1
 800091e:	fa01 f202 	lsl.w	r2, r1, r2
 8000922:	431a      	orrs	r2, r3
 8000924:	687b      	ldr	r3, [r7, #4]
 8000926:	60da      	str	r2, [r3, #12]
 8000928:	e026      	b.n	8000978 <GPIO_pinMode+0x14c>
	}else if (mode == INPUT_PULLDOWN){
 800092a:	78bb      	ldrb	r3, [r7, #2]
 800092c:	2b01      	cmp	r3, #1
 800092e:	d114      	bne.n	800095a <GPIO_pinMode+0x12e>
		*CRX |= (0x8 << (4*(pinIndex)));
 8000930:	7afb      	ldrb	r3, [r7, #11]
 8000932:	b2db      	uxtb	r3, r3
 8000934:	009b      	lsls	r3, r3, #2
 8000936:	2208      	movs	r2, #8
 8000938:	409a      	lsls	r2, r3
 800093a:	68fb      	ldr	r3, [r7, #12]
 800093c:	681b      	ldr	r3, [r3, #0]
 800093e:	431a      	orrs	r2, r3
 8000940:	68fb      	ldr	r3, [r7, #12]
 8000942:	601a      	str	r2, [r3, #0]
		CLEAR_BIT(GPIOX->ODR, pinNumber);
 8000944:	687b      	ldr	r3, [r7, #4]
 8000946:	68db      	ldr	r3, [r3, #12]
 8000948:	78fa      	ldrb	r2, [r7, #3]
 800094a:	2101      	movs	r1, #1
 800094c:	fa01 f202 	lsl.w	r2, r1, r2
 8000950:	43d2      	mvns	r2, r2
 8000952:	401a      	ands	r2, r3
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	60da      	str	r2, [r3, #12]
 8000958:	e00e      	b.n	8000978 <GPIO_pinMode+0x14c>
	}else if (mode == AF_PP){
 800095a:	78bb      	ldrb	r3, [r7, #2]
 800095c:	2b04      	cmp	r3, #4
 800095e:	d10b      	bne.n	8000978 <GPIO_pinMode+0x14c>
		*CRX |= (0xB << (4*(pinIndex)));
 8000960:	7afb      	ldrb	r3, [r7, #11]
 8000962:	b2db      	uxtb	r3, r3
 8000964:	009b      	lsls	r3, r3, #2
 8000966:	220b      	movs	r2, #11
 8000968:	409a      	lsls	r2, r3
 800096a:	68fb      	ldr	r3, [r7, #12]
 800096c:	681b      	ldr	r3, [r3, #0]
 800096e:	431a      	orrs	r2, r3
 8000970:	68fb      	ldr	r3, [r7, #12]
 8000972:	601a      	str	r2, [r3, #0]
 8000974:	e000      	b.n	8000978 <GPIO_pinMode+0x14c>
		return;
 8000976:	bf00      	nop

	}
}
 8000978:	3714      	adds	r7, #20
 800097a:	46bd      	mov	sp, r7
 800097c:	bc80      	pop	{r7}
 800097e:	4770      	bx	lr
 8000980:	40010800 	.word	0x40010800
 8000984:	40021000 	.word	0x40021000
 8000988:	40010c00 	.word	0x40010c00
 800098c:	40011000 	.word	0x40011000

08000990 <TIM2_IRQHandler>:
		millis = 0;
	}
	return millis;
}

void TIM2_IRQHandler() {
 8000990:	b598      	push	{r3, r4, r7, lr}
 8000992:	af00      	add	r7, sp, #0
	if (TIM2->SR & TIM_SR_CC1IF) {
 8000994:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000998:	691b      	ldr	r3, [r3, #16]
 800099a:	f003 0302 	and.w	r3, r3, #2
 800099e:	2b00      	cmp	r3, #0
 80009a0:	d01a      	beq.n	80009d8 <TIM2_IRQHandler+0x48>
		TIM2->SR &= ~TIM_SR_CC1IF;
 80009a2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80009a6:	691b      	ldr	r3, [r3, #16]
 80009a8:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80009ac:	f023 0302 	bic.w	r3, r3, #2
 80009b0:	6113      	str	r3, [r2, #16]
		TIM2->CCR1 = TIM2->CNT + trigTime_ms_global;
 80009b2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80009b6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80009b8:	4a1d      	ldr	r2, [pc, #116]	@ (8000a30 <TIM2_IRQHandler+0xa0>)
 80009ba:	8812      	ldrh	r2, [r2, #0]
 80009bc:	4614      	mov	r4, r2
 80009be:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80009c2:	4423      	add	r3, r4
 80009c4:	6353      	str	r3, [r2, #52]	@ 0x34
		millis++;
 80009c6:	4b1b      	ldr	r3, [pc, #108]	@ (8000a34 <TIM2_IRQHandler+0xa4>)
 80009c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80009cc:	1c50      	adds	r0, r2, #1
 80009ce:	f143 0100 	adc.w	r1, r3, #0
 80009d2:	4b18      	ldr	r3, [pc, #96]	@ (8000a34 <TIM2_IRQHandler+0xa4>)
 80009d4:	e9c3 0100 	strd	r0, r1, [r3]
//		if (isFirstTime) {
//			isFirstTime = 0;
//			millis = 0;
//		}
	}
	if ((TIM2->SR & (1 << 0)) == 1) { // check the uif flag
 80009d8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80009dc:	691b      	ldr	r3, [r3, #16]
 80009de:	f003 0301 	and.w	r3, r3, #1
 80009e2:	2b01      	cmp	r3, #1
 80009e4:	d122      	bne.n	8000a2c <TIM2_IRQHandler+0x9c>
		TIM2->SR &= ~(1 << 0); // clear the uif
 80009e6:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80009ea:	691b      	ldr	r3, [r3, #16]
 80009ec:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80009f0:	f023 0301 	bic.w	r3, r3, #1
 80009f4:	6113      	str	r3, [r2, #16]
		counter2++;
 80009f6:	4b10      	ldr	r3, [pc, #64]	@ (8000a38 <TIM2_IRQHandler+0xa8>)
 80009f8:	881b      	ldrh	r3, [r3, #0]
 80009fa:	b29b      	uxth	r3, r3
 80009fc:	3301      	adds	r3, #1
 80009fe:	b29a      	uxth	r2, r3
 8000a00:	4b0d      	ldr	r3, [pc, #52]	@ (8000a38 <TIM2_IRQHandler+0xa8>)
 8000a02:	801a      	strh	r2, [r3, #0]
		if (counter2 == n2) {
 8000a04:	4b0c      	ldr	r3, [pc, #48]	@ (8000a38 <TIM2_IRQHandler+0xa8>)
 8000a06:	881b      	ldrh	r3, [r3, #0]
 8000a08:	b29a      	uxth	r2, r3
 8000a0a:	4b0c      	ldr	r3, [pc, #48]	@ (8000a3c <TIM2_IRQHandler+0xac>)
 8000a0c:	881b      	ldrh	r3, [r3, #0]
 8000a0e:	b29b      	uxth	r3, r3
 8000a10:	429a      	cmp	r2, r3
 8000a12:	d10b      	bne.n	8000a2c <TIM2_IRQHandler+0x9c>
			counter2 = 0;
 8000a14:	4b08      	ldr	r3, [pc, #32]	@ (8000a38 <TIM2_IRQHandler+0xa8>)
 8000a16:	2200      	movs	r2, #0
 8000a18:	801a      	strh	r2, [r3, #0]
			TIM2->CNT = preload2; // set the preload
 8000a1a:	4b09      	ldr	r3, [pc, #36]	@ (8000a40 <TIM2_IRQHandler+0xb0>)
 8000a1c:	881b      	ldrh	r3, [r3, #0]
 8000a1e:	b29a      	uxth	r2, r3
 8000a20:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000a24:	625a      	str	r2, [r3, #36]	@ 0x24
			callback2();
 8000a26:	4b07      	ldr	r3, [pc, #28]	@ (8000a44 <TIM2_IRQHandler+0xb4>)
 8000a28:	681b      	ldr	r3, [r3, #0]
 8000a2a:	4798      	blx	r3
		}
	}
}
 8000a2c:	bf00      	nop
 8000a2e:	bd98      	pop	{r3, r4, r7, pc}
 8000a30:	20000058 	.word	0x20000058
 8000a34:	20000050 	.word	0x20000050
 8000a38:	20000038 	.word	0x20000038
 8000a3c:	20000032 	.word	0x20000032
 8000a40:	2000002c 	.word	0x2000002c
 8000a44:	20000040 	.word	0x20000040

08000a48 <TIM3_IRQHandler>:

void TIM3_IRQHandler() {
 8000a48:	b598      	push	{r3, r4, r7, lr}
 8000a4a:	af00      	add	r7, sp, #0
	if ((TIM3->SR & (1 << 0)) == 1) { // check the uif flag
 8000a4c:	4b25      	ldr	r3, [pc, #148]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a4e:	691b      	ldr	r3, [r3, #16]
 8000a50:	f003 0301 	and.w	r3, r3, #1
 8000a54:	2b01      	cmp	r3, #1
 8000a56:	d142      	bne.n	8000ade <TIM3_IRQHandler+0x96>
		if (TIM3->SR & TIM_SR_CC1IF) {
 8000a58:	4b22      	ldr	r3, [pc, #136]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a5a:	691b      	ldr	r3, [r3, #16]
 8000a5c:	f003 0302 	and.w	r3, r3, #2
 8000a60:	2b00      	cmp	r3, #0
 8000a62:	d016      	beq.n	8000a92 <TIM3_IRQHandler+0x4a>
			TIM3->SR &= ~TIM_SR_CC1IF;
 8000a64:	4b1f      	ldr	r3, [pc, #124]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a66:	691b      	ldr	r3, [r3, #16]
 8000a68:	4a1e      	ldr	r2, [pc, #120]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a6a:	f023 0302 	bic.w	r3, r3, #2
 8000a6e:	6113      	str	r3, [r2, #16]
			TIM3->CCR1 = TIM3->CNT + trigTime_ms_global;
 8000a70:	4b1c      	ldr	r3, [pc, #112]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a72:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000a74:	4a1c      	ldr	r2, [pc, #112]	@ (8000ae8 <TIM3_IRQHandler+0xa0>)
 8000a76:	8812      	ldrh	r2, [r2, #0]
 8000a78:	4614      	mov	r4, r2
 8000a7a:	4a1a      	ldr	r2, [pc, #104]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a7c:	4423      	add	r3, r4
 8000a7e:	6353      	str	r3, [r2, #52]	@ 0x34
			millis++;
 8000a80:	4b1a      	ldr	r3, [pc, #104]	@ (8000aec <TIM3_IRQHandler+0xa4>)
 8000a82:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000a86:	1c50      	adds	r0, r2, #1
 8000a88:	f143 0100 	adc.w	r1, r3, #0
 8000a8c:	4b17      	ldr	r3, [pc, #92]	@ (8000aec <TIM3_IRQHandler+0xa4>)
 8000a8e:	e9c3 0100 	strd	r0, r1, [r3]
//			if (isFirstTime) {
//				isFirstTime = 0;
//				millis = 0;
//			}
		}
		if ((TIM3->SR & (1 << 0)) == 1) {
 8000a92:	4b14      	ldr	r3, [pc, #80]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000a94:	691b      	ldr	r3, [r3, #16]
 8000a96:	f003 0301 	and.w	r3, r3, #1
 8000a9a:	2b01      	cmp	r3, #1
 8000a9c:	d11f      	bne.n	8000ade <TIM3_IRQHandler+0x96>
			TIM3->SR &= ~(1 << 0); // clear the uif
 8000a9e:	4b11      	ldr	r3, [pc, #68]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000aa0:	691b      	ldr	r3, [r3, #16]
 8000aa2:	4a10      	ldr	r2, [pc, #64]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000aa4:	f023 0301 	bic.w	r3, r3, #1
 8000aa8:	6113      	str	r3, [r2, #16]
			counter3++;
 8000aaa:	4b11      	ldr	r3, [pc, #68]	@ (8000af0 <TIM3_IRQHandler+0xa8>)
 8000aac:	881b      	ldrh	r3, [r3, #0]
 8000aae:	b29b      	uxth	r3, r3
 8000ab0:	3301      	adds	r3, #1
 8000ab2:	b29a      	uxth	r2, r3
 8000ab4:	4b0e      	ldr	r3, [pc, #56]	@ (8000af0 <TIM3_IRQHandler+0xa8>)
 8000ab6:	801a      	strh	r2, [r3, #0]
			if (counter3 == n3) {
 8000ab8:	4b0d      	ldr	r3, [pc, #52]	@ (8000af0 <TIM3_IRQHandler+0xa8>)
 8000aba:	881b      	ldrh	r3, [r3, #0]
 8000abc:	b29a      	uxth	r2, r3
 8000abe:	4b0d      	ldr	r3, [pc, #52]	@ (8000af4 <TIM3_IRQHandler+0xac>)
 8000ac0:	881b      	ldrh	r3, [r3, #0]
 8000ac2:	b29b      	uxth	r3, r3
 8000ac4:	429a      	cmp	r2, r3
 8000ac6:	d10a      	bne.n	8000ade <TIM3_IRQHandler+0x96>
				counter3 = 0;
 8000ac8:	4b09      	ldr	r3, [pc, #36]	@ (8000af0 <TIM3_IRQHandler+0xa8>)
 8000aca:	2200      	movs	r2, #0
 8000acc:	801a      	strh	r2, [r3, #0]
				TIM3->CNT = preload3; // set the preload
 8000ace:	4b0a      	ldr	r3, [pc, #40]	@ (8000af8 <TIM3_IRQHandler+0xb0>)
 8000ad0:	881b      	ldrh	r3, [r3, #0]
 8000ad2:	b29a      	uxth	r2, r3
 8000ad4:	4b03      	ldr	r3, [pc, #12]	@ (8000ae4 <TIM3_IRQHandler+0x9c>)
 8000ad6:	625a      	str	r2, [r3, #36]	@ 0x24
				callback3();
 8000ad8:	4b08      	ldr	r3, [pc, #32]	@ (8000afc <TIM3_IRQHandler+0xb4>)
 8000ada:	681b      	ldr	r3, [r3, #0]
 8000adc:	4798      	blx	r3
			}
		}
	}
}
 8000ade:	bf00      	nop
 8000ae0:	bd98      	pop	{r3, r4, r7, pc}
 8000ae2:	bf00      	nop
 8000ae4:	40000400 	.word	0x40000400
 8000ae8:	20000058 	.word	0x20000058
 8000aec:	20000050 	.word	0x20000050
 8000af0:	2000003a 	.word	0x2000003a
 8000af4:	20000034 	.word	0x20000034
 8000af8:	2000002e 	.word	0x2000002e
 8000afc:	20000044 	.word	0x20000044

08000b00 <TIM4_IRQHandler>:

void TIM4_IRQHandler() {
 8000b00:	b598      	push	{r3, r4, r7, lr}
 8000b02:	af00      	add	r7, sp, #0
	if ((TIM4->SR & (1 << 0)) == 1) { // check the uif flag
 8000b04:	4b25      	ldr	r3, [pc, #148]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b06:	691b      	ldr	r3, [r3, #16]
 8000b08:	f003 0301 	and.w	r3, r3, #1
 8000b0c:	2b01      	cmp	r3, #1
 8000b0e:	d142      	bne.n	8000b96 <TIM4_IRQHandler+0x96>
		if (TIM4->SR & TIM_SR_CC1IF) {
 8000b10:	4b22      	ldr	r3, [pc, #136]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b12:	691b      	ldr	r3, [r3, #16]
 8000b14:	f003 0302 	and.w	r3, r3, #2
 8000b18:	2b00      	cmp	r3, #0
 8000b1a:	d016      	beq.n	8000b4a <TIM4_IRQHandler+0x4a>
			TIM4->SR &= ~TIM_SR_CC1IF;
 8000b1c:	4b1f      	ldr	r3, [pc, #124]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b1e:	691b      	ldr	r3, [r3, #16]
 8000b20:	4a1e      	ldr	r2, [pc, #120]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b22:	f023 0302 	bic.w	r3, r3, #2
 8000b26:	6113      	str	r3, [r2, #16]
			TIM4->CCR1 = TIM4->CNT + trigTime_ms_global;
 8000b28:	4b1c      	ldr	r3, [pc, #112]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b2a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000b2c:	4a1c      	ldr	r2, [pc, #112]	@ (8000ba0 <TIM4_IRQHandler+0xa0>)
 8000b2e:	8812      	ldrh	r2, [r2, #0]
 8000b30:	4614      	mov	r4, r2
 8000b32:	4a1a      	ldr	r2, [pc, #104]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b34:	4423      	add	r3, r4
 8000b36:	6353      	str	r3, [r2, #52]	@ 0x34
			millis++;
 8000b38:	4b1a      	ldr	r3, [pc, #104]	@ (8000ba4 <TIM4_IRQHandler+0xa4>)
 8000b3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000b3e:	1c50      	adds	r0, r2, #1
 8000b40:	f143 0100 	adc.w	r1, r3, #0
 8000b44:	4b17      	ldr	r3, [pc, #92]	@ (8000ba4 <TIM4_IRQHandler+0xa4>)
 8000b46:	e9c3 0100 	strd	r0, r1, [r3]
//			if (isFirstTime) {
//				isFirstTime = 0;
//				millis = 0;
//			}
		}
		if ((TIM4->SR & (1 << 0)) == 1) {
 8000b4a:	4b14      	ldr	r3, [pc, #80]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b4c:	691b      	ldr	r3, [r3, #16]
 8000b4e:	f003 0301 	and.w	r3, r3, #1
 8000b52:	2b01      	cmp	r3, #1
 8000b54:	d11f      	bne.n	8000b96 <TIM4_IRQHandler+0x96>
			TIM4->SR &= ~(1 << 0); // clear the uif
 8000b56:	4b11      	ldr	r3, [pc, #68]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b58:	691b      	ldr	r3, [r3, #16]
 8000b5a:	4a10      	ldr	r2, [pc, #64]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b5c:	f023 0301 	bic.w	r3, r3, #1
 8000b60:	6113      	str	r3, [r2, #16]
			counter4++;
 8000b62:	4b11      	ldr	r3, [pc, #68]	@ (8000ba8 <TIM4_IRQHandler+0xa8>)
 8000b64:	881b      	ldrh	r3, [r3, #0]
 8000b66:	b29b      	uxth	r3, r3
 8000b68:	3301      	adds	r3, #1
 8000b6a:	b29a      	uxth	r2, r3
 8000b6c:	4b0e      	ldr	r3, [pc, #56]	@ (8000ba8 <TIM4_IRQHandler+0xa8>)
 8000b6e:	801a      	strh	r2, [r3, #0]
			if (counter4 == n4) {
 8000b70:	4b0d      	ldr	r3, [pc, #52]	@ (8000ba8 <TIM4_IRQHandler+0xa8>)
 8000b72:	881b      	ldrh	r3, [r3, #0]
 8000b74:	b29a      	uxth	r2, r3
 8000b76:	4b0d      	ldr	r3, [pc, #52]	@ (8000bac <TIM4_IRQHandler+0xac>)
 8000b78:	881b      	ldrh	r3, [r3, #0]
 8000b7a:	b29b      	uxth	r3, r3
 8000b7c:	429a      	cmp	r2, r3
 8000b7e:	d10a      	bne.n	8000b96 <TIM4_IRQHandler+0x96>
				counter4 = 0;
 8000b80:	4b09      	ldr	r3, [pc, #36]	@ (8000ba8 <TIM4_IRQHandler+0xa8>)
 8000b82:	2200      	movs	r2, #0
 8000b84:	801a      	strh	r2, [r3, #0]
				TIM4->CNT = preload4; // set the preload
 8000b86:	4b0a      	ldr	r3, [pc, #40]	@ (8000bb0 <TIM4_IRQHandler+0xb0>)
 8000b88:	881b      	ldrh	r3, [r3, #0]
 8000b8a:	b29a      	uxth	r2, r3
 8000b8c:	4b03      	ldr	r3, [pc, #12]	@ (8000b9c <TIM4_IRQHandler+0x9c>)
 8000b8e:	625a      	str	r2, [r3, #36]	@ 0x24
				callback4();
 8000b90:	4b08      	ldr	r3, [pc, #32]	@ (8000bb4 <TIM4_IRQHandler+0xb4>)
 8000b92:	681b      	ldr	r3, [r3, #0]
 8000b94:	4798      	blx	r3
			}
		}
	}
}
 8000b96:	bf00      	nop
 8000b98:	bd98      	pop	{r3, r4, r7, pc}
 8000b9a:	bf00      	nop
 8000b9c:	40000800 	.word	0x40000800
 8000ba0:	20000058 	.word	0x20000058
 8000ba4:	20000050 	.word	0x20000050
 8000ba8:	2000003c 	.word	0x2000003c
 8000bac:	20000036 	.word	0x20000036
 8000bb0:	20000030 	.word	0x20000030
 8000bb4:	20000048 	.word	0x20000048

08000bb8 <UART_init>:
#include "../GPIO/GPIO_interface.h"

#define RX_BUFFER_LEN 64

void UART_init(int UART_pref_num, int baudrate)
{
 8000bb8:	b590      	push	{r4, r7, lr}
 8000bba:	b087      	sub	sp, #28
 8000bbc:	af00      	add	r7, sp, #0
 8000bbe:	6078      	str	r0, [r7, #4]
 8000bc0:	6039      	str	r1, [r7, #0]
    USART_TypeDef *USARTx;
    uint32_t pclk = 8000000; // 8 MHz clock
 8000bc2:	4b57      	ldr	r3, [pc, #348]	@ (8000d20 <UART_init+0x168>)
 8000bc4:	613b      	str	r3, [r7, #16]
    //uint32_t brr_value; //unused var

    switch (UART_pref_num)
 8000bc6:	687b      	ldr	r3, [r7, #4]
 8000bc8:	2b03      	cmp	r3, #3
 8000bca:	d03c      	beq.n	8000c46 <UART_init+0x8e>
 8000bcc:	687b      	ldr	r3, [r7, #4]
 8000bce:	2b03      	cmp	r3, #3
 8000bd0:	f300 80a2 	bgt.w	8000d18 <UART_init+0x160>
 8000bd4:	687b      	ldr	r3, [r7, #4]
 8000bd6:	2b01      	cmp	r3, #1
 8000bd8:	d003      	beq.n	8000be2 <UART_init+0x2a>
 8000bda:	687b      	ldr	r3, [r7, #4]
 8000bdc:	2b02      	cmp	r3, #2
 8000bde:	d019      	beq.n	8000c14 <UART_init+0x5c>
        GPIO_pinMode(GPIOB, 11, INPUT_FLOAT); // RX
        USARTx = USART3;
        break;

    default:
        return;
 8000be0:	e09a      	b.n	8000d18 <UART_init+0x160>
        SET_BIT(RCC->APB2ENR, 14);            // USART1
 8000be2:	4b50      	ldr	r3, [pc, #320]	@ (8000d24 <UART_init+0x16c>)
 8000be4:	699b      	ldr	r3, [r3, #24]
 8000be6:	4a4f      	ldr	r2, [pc, #316]	@ (8000d24 <UART_init+0x16c>)
 8000be8:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000bec:	6193      	str	r3, [r2, #24]
        SET_BIT(RCC->APB2ENR, 2);             // GPIOA
 8000bee:	4b4d      	ldr	r3, [pc, #308]	@ (8000d24 <UART_init+0x16c>)
 8000bf0:	699b      	ldr	r3, [r3, #24]
 8000bf2:	4a4c      	ldr	r2, [pc, #304]	@ (8000d24 <UART_init+0x16c>)
 8000bf4:	f043 0304 	orr.w	r3, r3, #4
 8000bf8:	6193      	str	r3, [r2, #24]
        GPIO_pinMode(GPIOA, 9, AF_PP);        // TX
 8000bfa:	2204      	movs	r2, #4
 8000bfc:	2109      	movs	r1, #9
 8000bfe:	484a      	ldr	r0, [pc, #296]	@ (8000d28 <UART_init+0x170>)
 8000c00:	f7ff fe14 	bl	800082c <GPIO_pinMode>
        GPIO_pinMode(GPIOA, 10, INPUT_FLOAT); // RX
 8000c04:	2202      	movs	r2, #2
 8000c06:	210a      	movs	r1, #10
 8000c08:	4847      	ldr	r0, [pc, #284]	@ (8000d28 <UART_init+0x170>)
 8000c0a:	f7ff fe0f 	bl	800082c <GPIO_pinMode>
        USARTx = USART1;
 8000c0e:	4b47      	ldr	r3, [pc, #284]	@ (8000d2c <UART_init+0x174>)
 8000c10:	617b      	str	r3, [r7, #20]
        break;
 8000c12:	e031      	b.n	8000c78 <UART_init+0xc0>
        SET_BIT(RCC->APB1ENR, 17);           // USART2
 8000c14:	4b43      	ldr	r3, [pc, #268]	@ (8000d24 <UART_init+0x16c>)
 8000c16:	69db      	ldr	r3, [r3, #28]
 8000c18:	4a42      	ldr	r2, [pc, #264]	@ (8000d24 <UART_init+0x16c>)
 8000c1a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000c1e:	61d3      	str	r3, [r2, #28]
        SET_BIT(RCC->APB2ENR, 2);            // GPIOA
 8000c20:	4b40      	ldr	r3, [pc, #256]	@ (8000d24 <UART_init+0x16c>)
 8000c22:	699b      	ldr	r3, [r3, #24]
 8000c24:	4a3f      	ldr	r2, [pc, #252]	@ (8000d24 <UART_init+0x16c>)
 8000c26:	f043 0304 	orr.w	r3, r3, #4
 8000c2a:	6193      	str	r3, [r2, #24]
        GPIO_pinMode(GPIOA, 2, AF_PP);       // TX
 8000c2c:	2204      	movs	r2, #4
 8000c2e:	2102      	movs	r1, #2
 8000c30:	483d      	ldr	r0, [pc, #244]	@ (8000d28 <UART_init+0x170>)
 8000c32:	f7ff fdfb 	bl	800082c <GPIO_pinMode>
        GPIO_pinMode(GPIOA, 3, INPUT_FLOAT); // RX
 8000c36:	2202      	movs	r2, #2
 8000c38:	2103      	movs	r1, #3
 8000c3a:	483b      	ldr	r0, [pc, #236]	@ (8000d28 <UART_init+0x170>)
 8000c3c:	f7ff fdf6 	bl	800082c <GPIO_pinMode>
        USARTx = USART2;
 8000c40:	4b3b      	ldr	r3, [pc, #236]	@ (8000d30 <UART_init+0x178>)
 8000c42:	617b      	str	r3, [r7, #20]
        break;
 8000c44:	e018      	b.n	8000c78 <UART_init+0xc0>
        SET_BIT(RCC->APB1ENR, 18);            // USART3
 8000c46:	4b37      	ldr	r3, [pc, #220]	@ (8000d24 <UART_init+0x16c>)
 8000c48:	69db      	ldr	r3, [r3, #28]
 8000c4a:	4a36      	ldr	r2, [pc, #216]	@ (8000d24 <UART_init+0x16c>)
 8000c4c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8000c50:	61d3      	str	r3, [r2, #28]
        SET_BIT(RCC->APB2ENR, 3);             // GPIOB
 8000c52:	4b34      	ldr	r3, [pc, #208]	@ (8000d24 <UART_init+0x16c>)
 8000c54:	699b      	ldr	r3, [r3, #24]
 8000c56:	4a33      	ldr	r2, [pc, #204]	@ (8000d24 <UART_init+0x16c>)
 8000c58:	f043 0308 	orr.w	r3, r3, #8
 8000c5c:	6193      	str	r3, [r2, #24]
        GPIO_pinMode(GPIOB, 10, AF_PP);       // TX
 8000c5e:	2204      	movs	r2, #4
 8000c60:	210a      	movs	r1, #10
 8000c62:	4834      	ldr	r0, [pc, #208]	@ (8000d34 <UART_init+0x17c>)
 8000c64:	f7ff fde2 	bl	800082c <GPIO_pinMode>
        GPIO_pinMode(GPIOB, 11, INPUT_FLOAT); // RX
 8000c68:	2202      	movs	r2, #2
 8000c6a:	210b      	movs	r1, #11
 8000c6c:	4831      	ldr	r0, [pc, #196]	@ (8000d34 <UART_init+0x17c>)
 8000c6e:	f7ff fddd 	bl	800082c <GPIO_pinMode>
        USARTx = USART3;
 8000c72:	4b31      	ldr	r3, [pc, #196]	@ (8000d38 <UART_init+0x180>)
 8000c74:	617b      	str	r3, [r7, #20]
        break;
 8000c76:	bf00      	nop
    }

    // Baud Rate Calculation for 8 MHz clock
    float usartdiv = (float)pclk / (16.0f * baudrate);
 8000c78:	6938      	ldr	r0, [r7, #16]
 8000c7a:	f7ff fb1f 	bl	80002bc <__aeabi_ui2f>
 8000c7e:	4604      	mov	r4, r0
 8000c80:	6838      	ldr	r0, [r7, #0]
 8000c82:	f7ff fb1f 	bl	80002c4 <__aeabi_i2f>
 8000c86:	4603      	mov	r3, r0
 8000c88:	f04f 4183 	mov.w	r1, #1098907648	@ 0x41800000
 8000c8c:	4618      	mov	r0, r3
 8000c8e:	f7ff fb6d 	bl	800036c <__aeabi_fmul>
 8000c92:	4603      	mov	r3, r0
 8000c94:	4619      	mov	r1, r3
 8000c96:	4620      	mov	r0, r4
 8000c98:	f7ff fc1c 	bl	80004d4 <__aeabi_fdiv>
 8000c9c:	4603      	mov	r3, r0
 8000c9e:	60fb      	str	r3, [r7, #12]
    uint16_t mantissa = (uint16_t)usartdiv;
 8000ca0:	68f8      	ldr	r0, [r7, #12]
 8000ca2:	f7ff fcb3 	bl	800060c <__aeabi_f2uiz>
 8000ca6:	4603      	mov	r3, r0
 8000ca8:	817b      	strh	r3, [r7, #10]
    uint16_t fraction = (uint16_t)((usartdiv - mantissa) * 16.0f + 0.5f); // rounded
 8000caa:	897b      	ldrh	r3, [r7, #10]
 8000cac:	4618      	mov	r0, r3
 8000cae:	f7ff fb09 	bl	80002c4 <__aeabi_i2f>
 8000cb2:	4603      	mov	r3, r0
 8000cb4:	4619      	mov	r1, r3
 8000cb6:	68f8      	ldr	r0, [r7, #12]
 8000cb8:	f7ff fa4e 	bl	8000158 <__aeabi_fsub>
 8000cbc:	4603      	mov	r3, r0
 8000cbe:	f04f 4183 	mov.w	r1, #1098907648	@ 0x41800000
 8000cc2:	4618      	mov	r0, r3
 8000cc4:	f7ff fb52 	bl	800036c <__aeabi_fmul>
 8000cc8:	4603      	mov	r3, r0
 8000cca:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
 8000cce:	4618      	mov	r0, r3
 8000cd0:	f7ff fa44 	bl	800015c <__addsf3>
 8000cd4:	4603      	mov	r3, r0
 8000cd6:	4618      	mov	r0, r3
 8000cd8:	f7ff fc98 	bl	800060c <__aeabi_f2uiz>
 8000cdc:	4603      	mov	r3, r0
 8000cde:	813b      	strh	r3, [r7, #8]

    USARTx->BRR = (mantissa << 4) | (fraction & 0xF);
 8000ce0:	897b      	ldrh	r3, [r7, #10]
 8000ce2:	011a      	lsls	r2, r3, #4
 8000ce4:	893b      	ldrh	r3, [r7, #8]
 8000ce6:	f003 030f 	and.w	r3, r3, #15
 8000cea:	4313      	orrs	r3, r2
 8000cec:	461a      	mov	r2, r3
 8000cee:	697b      	ldr	r3, [r7, #20]
 8000cf0:	609a      	str	r2, [r3, #8]

    // Enable USART, TX, RX
    SET_BIT(USARTx->CR1, 13); // UE
 8000cf2:	697b      	ldr	r3, [r7, #20]
 8000cf4:	68db      	ldr	r3, [r3, #12]
 8000cf6:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
 8000cfa:	697b      	ldr	r3, [r7, #20]
 8000cfc:	60da      	str	r2, [r3, #12]
    SET_BIT(USARTx->CR1, 3);  // TE
 8000cfe:	697b      	ldr	r3, [r7, #20]
 8000d00:	68db      	ldr	r3, [r3, #12]
 8000d02:	f043 0208 	orr.w	r2, r3, #8
 8000d06:	697b      	ldr	r3, [r7, #20]
 8000d08:	60da      	str	r2, [r3, #12]
    SET_BIT(USARTx->CR1, 2);  // RE
 8000d0a:	697b      	ldr	r3, [r7, #20]
 8000d0c:	68db      	ldr	r3, [r3, #12]
 8000d0e:	f043 0204 	orr.w	r2, r3, #4
 8000d12:	697b      	ldr	r3, [r7, #20]
 8000d14:	60da      	str	r2, [r3, #12]
 8000d16:	e000      	b.n	8000d1a <UART_init+0x162>
        return;
 8000d18:	bf00      	nop
}
 8000d1a:	371c      	adds	r7, #28
 8000d1c:	46bd      	mov	sp, r7
 8000d1e:	bd90      	pop	{r4, r7, pc}
 8000d20:	007a1200 	.word	0x007a1200
 8000d24:	40021000 	.word	0x40021000
 8000d28:	40010800 	.word	0x40010800
 8000d2c:	40013800 	.word	0x40013800
 8000d30:	40004400 	.word	0x40004400
 8000d34:	40010c00 	.word	0x40010c00
 8000d38:	40004800 	.word	0x40004800

08000d3c <UART_receive_message>:
    while (!(USARTx->SR & (1 << 5)));

    return USARTx->DR & 0xFF;
}

UARTMessage UART_receive_message(int UART_pref_num) {
 8000d3c:	b490      	push	{r4, r7}
 8000d3e:	b096      	sub	sp, #88	@ 0x58
 8000d40:	af00      	add	r7, sp, #0
 8000d42:	6078      	str	r0, [r7, #4]
 8000d44:	6039      	str	r1, [r7, #0]
    static uint8_t buffer[3];
    static uint8_t index = 0;
    static uint8_t checksum = 0;

    USART_TypeDef *USARTx;
    switch (UART_pref_num) {
 8000d46:	683b      	ldr	r3, [r7, #0]
 8000d48:	2b03      	cmp	r3, #3
 8000d4a:	d00f      	beq.n	8000d6c <UART_receive_message+0x30>
 8000d4c:	683b      	ldr	r3, [r7, #0]
 8000d4e:	2b03      	cmp	r3, #3
 8000d50:	dc0f      	bgt.n	8000d72 <UART_receive_message+0x36>
 8000d52:	683b      	ldr	r3, [r7, #0]
 8000d54:	2b01      	cmp	r3, #1
 8000d56:	d003      	beq.n	8000d60 <UART_receive_message+0x24>
 8000d58:	683b      	ldr	r3, [r7, #0]
 8000d5a:	2b02      	cmp	r3, #2
 8000d5c:	d003      	beq.n	8000d66 <UART_receive_message+0x2a>
 8000d5e:	e008      	b.n	8000d72 <UART_receive_message+0x36>
        case 1: USARTx = USART1; break;
 8000d60:	4b60      	ldr	r3, [pc, #384]	@ (8000ee4 <UART_receive_message+0x1a8>)
 8000d62:	657b      	str	r3, [r7, #84]	@ 0x54
 8000d64:	e00c      	b.n	8000d80 <UART_receive_message+0x44>
        case 2: USARTx = USART2; break;
 8000d66:	4b60      	ldr	r3, [pc, #384]	@ (8000ee8 <UART_receive_message+0x1ac>)
 8000d68:	657b      	str	r3, [r7, #84]	@ 0x54
 8000d6a:	e009      	b.n	8000d80 <UART_receive_message+0x44>
        case 3: USARTx = USART3; break;
 8000d6c:	4b5f      	ldr	r3, [pc, #380]	@ (8000eec <UART_receive_message+0x1b0>)
 8000d6e:	657b      	str	r3, [r7, #84]	@ 0x54
 8000d70:	e006      	b.n	8000d80 <UART_receive_message+0x44>
        default: return (UARTMessage){ .type = MSG_NONE };
 8000d72:	687b      	ldr	r3, [r7, #4]
 8000d74:	461a      	mov	r2, r3
 8000d76:	2300      	movs	r3, #0
 8000d78:	6013      	str	r3, [r2, #0]
 8000d7a:	6053      	str	r3, [r2, #4]
 8000d7c:	6093      	str	r3, [r2, #8]
            }
            break;
    }

    return (UARTMessage){ .type = MSG_NONE };
}
 8000d7e:	e0ac      	b.n	8000eda <UART_receive_message+0x19e>
    if (!(USARTx->SR & USART_SR_RXNE)) return (UARTMessage){ .type = MSG_NONE };
 8000d80:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8000d82:	681b      	ldr	r3, [r3, #0]
 8000d84:	f003 0320 	and.w	r3, r3, #32
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d106      	bne.n	8000d9a <UART_receive_message+0x5e>
 8000d8c:	687b      	ldr	r3, [r7, #4]
 8000d8e:	461a      	mov	r2, r3
 8000d90:	2300      	movs	r3, #0
 8000d92:	6013      	str	r3, [r2, #0]
 8000d94:	6053      	str	r3, [r2, #4]
 8000d96:	6093      	str	r3, [r2, #8]
 8000d98:	e09f      	b.n	8000eda <UART_receive_message+0x19e>
    uint8_t byte = USARTx->DR & 0xFF;
 8000d9a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8000d9c:	685b      	ldr	r3, [r3, #4]
 8000d9e:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    switch (state) {
 8000da2:	4b53      	ldr	r3, [pc, #332]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000da4:	781b      	ldrb	r3, [r3, #0]
 8000da6:	2b03      	cmp	r3, #3
 8000da8:	f200 8091 	bhi.w	8000ece <UART_receive_message+0x192>
 8000dac:	a201      	add	r2, pc, #4	@ (adr r2, 8000db4 <UART_receive_message+0x78>)
 8000dae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000db2:	bf00      	nop
 8000db4:	08000dc5 	.word	0x08000dc5
 8000db8:	08000de1 	.word	0x08000de1
 8000dbc:	08000e17 	.word	0x08000e17
 8000dc0:	08000e33 	.word	0x08000e33
            if (byte == 0xAA) {
 8000dc4:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8000dc8:	2baa      	cmp	r3, #170	@ 0xaa
 8000dca:	d17d      	bne.n	8000ec8 <UART_receive_message+0x18c>
                index = 0;
 8000dcc:	4b49      	ldr	r3, [pc, #292]	@ (8000ef4 <UART_receive_message+0x1b8>)
 8000dce:	2200      	movs	r2, #0
 8000dd0:	701a      	strb	r2, [r3, #0]
                checksum = 0;
 8000dd2:	4b49      	ldr	r3, [pc, #292]	@ (8000ef8 <UART_receive_message+0x1bc>)
 8000dd4:	2200      	movs	r2, #0
 8000dd6:	701a      	strb	r2, [r3, #0]
                state = READ_DATA;
 8000dd8:	4b45      	ldr	r3, [pc, #276]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000dda:	2201      	movs	r2, #1
 8000ddc:	701a      	strb	r2, [r3, #0]
            break;
 8000dde:	e073      	b.n	8000ec8 <UART_receive_message+0x18c>
            buffer[index++] = byte;
 8000de0:	4b44      	ldr	r3, [pc, #272]	@ (8000ef4 <UART_receive_message+0x1b8>)
 8000de2:	781b      	ldrb	r3, [r3, #0]
 8000de4:	1c5a      	adds	r2, r3, #1
 8000de6:	b2d1      	uxtb	r1, r2
 8000de8:	4a42      	ldr	r2, [pc, #264]	@ (8000ef4 <UART_receive_message+0x1b8>)
 8000dea:	7011      	strb	r1, [r2, #0]
 8000dec:	4619      	mov	r1, r3
 8000dee:	4a43      	ldr	r2, [pc, #268]	@ (8000efc <UART_receive_message+0x1c0>)
 8000df0:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8000df4:	5453      	strb	r3, [r2, r1]
            checksum ^= byte;
 8000df6:	4b40      	ldr	r3, [pc, #256]	@ (8000ef8 <UART_receive_message+0x1bc>)
 8000df8:	781a      	ldrb	r2, [r3, #0]
 8000dfa:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8000dfe:	4053      	eors	r3, r2
 8000e00:	b2da      	uxtb	r2, r3
 8000e02:	4b3d      	ldr	r3, [pc, #244]	@ (8000ef8 <UART_receive_message+0x1bc>)
 8000e04:	701a      	strb	r2, [r3, #0]
            if (index == 3) state = READ_CHECKSUM;
 8000e06:	4b3b      	ldr	r3, [pc, #236]	@ (8000ef4 <UART_receive_message+0x1b8>)
 8000e08:	781b      	ldrb	r3, [r3, #0]
 8000e0a:	2b03      	cmp	r3, #3
 8000e0c:	d15e      	bne.n	8000ecc <UART_receive_message+0x190>
 8000e0e:	4b38      	ldr	r3, [pc, #224]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000e10:	2202      	movs	r2, #2
 8000e12:	701a      	strb	r2, [r3, #0]
            break;
 8000e14:	e05a      	b.n	8000ecc <UART_receive_message+0x190>
            if (byte == checksum) {
 8000e16:	4b38      	ldr	r3, [pc, #224]	@ (8000ef8 <UART_receive_message+0x1bc>)
 8000e18:	781b      	ldrb	r3, [r3, #0]
 8000e1a:	f897 204f 	ldrb.w	r2, [r7, #79]	@ 0x4f
 8000e1e:	429a      	cmp	r2, r3
 8000e20:	d103      	bne.n	8000e2a <UART_receive_message+0xee>
                state = WAIT_END;
 8000e22:	4b33      	ldr	r3, [pc, #204]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000e24:	2203      	movs	r2, #3
 8000e26:	701a      	strb	r2, [r3, #0]
            break;
 8000e28:	e051      	b.n	8000ece <UART_receive_message+0x192>
                state = WAIT_START;
 8000e2a:	4b31      	ldr	r3, [pc, #196]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000e2c:	2200      	movs	r2, #0
 8000e2e:	701a      	strb	r2, [r3, #0]
            break;
 8000e30:	e04d      	b.n	8000ece <UART_receive_message+0x192>
            if (byte == 0x55) {
 8000e32:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8000e36:	2b55      	cmp	r3, #85	@ 0x55
 8000e38:	d142      	bne.n	8000ec0 <UART_receive_message+0x184>
                while (!(USARTx->SR & USART_SR_TXE));
 8000e3a:	bf00      	nop
 8000e3c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8000e3e:	681b      	ldr	r3, [r3, #0]
 8000e40:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000e44:	2b00      	cmp	r3, #0
 8000e46:	d0f9      	beq.n	8000e3c <UART_receive_message+0x100>
                USARTx->DR = 0xCC;
 8000e48:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8000e4a:	22cc      	movs	r2, #204	@ 0xcc
 8000e4c:	605a      	str	r2, [r3, #4]
                uint32_t packed = (buffer[0] << 16) | (buffer[1] << 8) | buffer[2];
 8000e4e:	4b2b      	ldr	r3, [pc, #172]	@ (8000efc <UART_receive_message+0x1c0>)
 8000e50:	781b      	ldrb	r3, [r3, #0]
 8000e52:	041a      	lsls	r2, r3, #16
 8000e54:	4b29      	ldr	r3, [pc, #164]	@ (8000efc <UART_receive_message+0x1c0>)
 8000e56:	785b      	ldrb	r3, [r3, #1]
 8000e58:	021b      	lsls	r3, r3, #8
 8000e5a:	4313      	orrs	r3, r2
 8000e5c:	4a27      	ldr	r2, [pc, #156]	@ (8000efc <UART_receive_message+0x1c0>)
 8000e5e:	7892      	ldrb	r2, [r2, #2]
 8000e60:	4313      	orrs	r3, r2
 8000e62:	64bb      	str	r3, [r7, #72]	@ 0x48
                int command = (packed >> 23) & 0x01;
 8000e64:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8000e66:	0ddb      	lsrs	r3, r3, #23
 8000e68:	f003 0301 	and.w	r3, r3, #1
 8000e6c:	647b      	str	r3, [r7, #68]	@ 0x44
                int distance = (packed >> 8) & 0x7FFF;
 8000e6e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8000e70:	0a1b      	lsrs	r3, r3, #8
 8000e72:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000e76:	643b      	str	r3, [r7, #64]	@ 0x40
                int sign = (packed >> 7) & 0x01;
 8000e78:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8000e7a:	09db      	lsrs	r3, r3, #7
 8000e7c:	f003 0301 	and.w	r3, r3, #1
 8000e80:	63fb      	str	r3, [r7, #60]	@ 0x3c
                int angle = packed & 0x7F;
 8000e82:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8000e84:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8000e88:	653b      	str	r3, [r7, #80]	@ 0x50
                if (sign) angle = -angle;
 8000e8a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8000e8c:	2b00      	cmp	r3, #0
 8000e8e:	d002      	beq.n	8000e96 <UART_receive_message+0x15a>
 8000e90:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8000e92:	425b      	negs	r3, r3
 8000e94:	653b      	str	r3, [r7, #80]	@ 0x50
                UARTMessage msg = {
 8000e96:	2305      	movs	r3, #5
 8000e98:	733b      	strb	r3, [r7, #12]
 8000e9a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8000e9c:	b29b      	uxth	r3, r3
 8000e9e:	81fb      	strh	r3, [r7, #14]
 8000ea0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8000ea2:	613b      	str	r3, [r7, #16]
 8000ea4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8000ea6:	617b      	str	r3, [r7, #20]
                state = WAIT_START;
 8000ea8:	4b11      	ldr	r3, [pc, #68]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000eaa:	2200      	movs	r2, #0
 8000eac:	701a      	strb	r2, [r3, #0]
                return msg;
 8000eae:	687b      	ldr	r3, [r7, #4]
 8000eb0:	461c      	mov	r4, r3
 8000eb2:	f107 030c 	add.w	r3, r7, #12
 8000eb6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8000eba:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8000ebe:	e00c      	b.n	8000eda <UART_receive_message+0x19e>
                state = WAIT_START;
 8000ec0:	4b0b      	ldr	r3, [pc, #44]	@ (8000ef0 <UART_receive_message+0x1b4>)
 8000ec2:	2200      	movs	r2, #0
 8000ec4:	701a      	strb	r2, [r3, #0]
            break;
 8000ec6:	e002      	b.n	8000ece <UART_receive_message+0x192>
            break;
 8000ec8:	bf00      	nop
 8000eca:	e000      	b.n	8000ece <UART_receive_message+0x192>
            break;
 8000ecc:	bf00      	nop
    return (UARTMessage){ .type = MSG_NONE };
 8000ece:	687b      	ldr	r3, [r7, #4]
 8000ed0:	461a      	mov	r2, r3
 8000ed2:	2300      	movs	r3, #0
 8000ed4:	6013      	str	r3, [r2, #0]
 8000ed6:	6053      	str	r3, [r2, #4]
 8000ed8:	6093      	str	r3, [r2, #8]
}
 8000eda:	6878      	ldr	r0, [r7, #4]
 8000edc:	3758      	adds	r7, #88	@ 0x58
 8000ede:	46bd      	mov	sp, r7
 8000ee0:	bc90      	pop	{r4, r7}
 8000ee2:	4770      	bx	lr
 8000ee4:	40013800 	.word	0x40013800
 8000ee8:	40004400 	.word	0x40004400
 8000eec:	40004800 	.word	0x40004800
 8000ef0:	2000005a 	.word	0x2000005a
 8000ef4:	2000005b 	.word	0x2000005b
 8000ef8:	2000005c 	.word	0x2000005c
 8000efc:	20000060 	.word	0x20000060

08000f00 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8000f00:	b480      	push	{r7}
 8000f02:	b085      	sub	sp, #20
 8000f04:	af00      	add	r7, sp, #0
 8000f06:	6078      	str	r0, [r7, #4]
 8000f08:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 8000f0a:	687b      	ldr	r3, [r7, #4]
 8000f0c:	685b      	ldr	r3, [r3, #4]
 8000f0e:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8000f10:	683b      	ldr	r3, [r7, #0]
 8000f12:	68fa      	ldr	r2, [r7, #12]
 8000f14:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000f16:	68fb      	ldr	r3, [r7, #12]
 8000f18:	689a      	ldr	r2, [r3, #8]
 8000f1a:	683b      	ldr	r3, [r7, #0]
 8000f1c:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8000f1e:	68fb      	ldr	r3, [r7, #12]
 8000f20:	689b      	ldr	r3, [r3, #8]
 8000f22:	683a      	ldr	r2, [r7, #0]
 8000f24:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8000f26:	68fb      	ldr	r3, [r7, #12]
 8000f28:	683a      	ldr	r2, [r7, #0]
 8000f2a:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 8000f2c:	683b      	ldr	r3, [r7, #0]
 8000f2e:	687a      	ldr	r2, [r7, #4]
 8000f30:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000f32:	687b      	ldr	r3, [r7, #4]
 8000f34:	681b      	ldr	r3, [r3, #0]
 8000f36:	1c5a      	adds	r2, r3, #1
 8000f38:	687b      	ldr	r3, [r7, #4]
 8000f3a:	601a      	str	r2, [r3, #0]
}
 8000f3c:	bf00      	nop
 8000f3e:	3714      	adds	r7, #20
 8000f40:	46bd      	mov	sp, r7
 8000f42:	bc80      	pop	{r7}
 8000f44:	4770      	bx	lr

08000f46 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8000f46:	b480      	push	{r7}
 8000f48:	b085      	sub	sp, #20
 8000f4a:	af00      	add	r7, sp, #0
 8000f4c:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8000f4e:	687b      	ldr	r3, [r7, #4]
 8000f50:	691b      	ldr	r3, [r3, #16]
 8000f52:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000f54:	687b      	ldr	r3, [r7, #4]
 8000f56:	685b      	ldr	r3, [r3, #4]
 8000f58:	687a      	ldr	r2, [r7, #4]
 8000f5a:	6892      	ldr	r2, [r2, #8]
 8000f5c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000f5e:	687b      	ldr	r3, [r7, #4]
 8000f60:	689b      	ldr	r3, [r3, #8]
 8000f62:	687a      	ldr	r2, [r7, #4]
 8000f64:	6852      	ldr	r2, [r2, #4]
 8000f66:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000f68:	68fb      	ldr	r3, [r7, #12]
 8000f6a:	685b      	ldr	r3, [r3, #4]
 8000f6c:	687a      	ldr	r2, [r7, #4]
 8000f6e:	429a      	cmp	r2, r3
 8000f70:	d103      	bne.n	8000f7a <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000f72:	687b      	ldr	r3, [r7, #4]
 8000f74:	689a      	ldr	r2, [r3, #8]
 8000f76:	68fb      	ldr	r3, [r7, #12]
 8000f78:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8000f7a:	687b      	ldr	r3, [r7, #4]
 8000f7c:	2200      	movs	r2, #0
 8000f7e:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8000f80:	68fb      	ldr	r3, [r7, #12]
 8000f82:	681b      	ldr	r3, [r3, #0]
 8000f84:	1e5a      	subs	r2, r3, #1
 8000f86:	68fb      	ldr	r3, [r7, #12]
 8000f88:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8000f8a:	68fb      	ldr	r3, [r7, #12]
 8000f8c:	681b      	ldr	r3, [r3, #0]
}
 8000f8e:	4618      	mov	r0, r3
 8000f90:	3714      	adds	r7, #20
 8000f92:	46bd      	mov	sp, r7
 8000f94:	bc80      	pop	{r7}
 8000f96:	4770      	bx	lr

08000f98 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8000f98:	b580      	push	{r7, lr}
 8000f9a:	b086      	sub	sp, #24
 8000f9c:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8000f9e:	2300      	movs	r3, #0
 8000fa0:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000fa2:	4b4f      	ldr	r3, [pc, #316]	@ (80010e0 <xTaskIncrementTick+0x148>)
 8000fa4:	681b      	ldr	r3, [r3, #0]
 8000fa6:	2b00      	cmp	r3, #0
 8000fa8:	f040 808f 	bne.w	80010ca <xTaskIncrementTick+0x132>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8000fac:	4b4d      	ldr	r3, [pc, #308]	@ (80010e4 <xTaskIncrementTick+0x14c>)
 8000fae:	681b      	ldr	r3, [r3, #0]
 8000fb0:	3301      	adds	r3, #1
 8000fb2:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8000fb4:	4a4b      	ldr	r2, [pc, #300]	@ (80010e4 <xTaskIncrementTick+0x14c>)
 8000fb6:	693b      	ldr	r3, [r7, #16]
 8000fb8:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8000fba:	693b      	ldr	r3, [r7, #16]
 8000fbc:	2b00      	cmp	r3, #0
 8000fbe:	d121      	bne.n	8001004 <xTaskIncrementTick+0x6c>
		{
			taskSWITCH_DELAYED_LISTS();
 8000fc0:	4b49      	ldr	r3, [pc, #292]	@ (80010e8 <xTaskIncrementTick+0x150>)
 8000fc2:	681b      	ldr	r3, [r3, #0]
 8000fc4:	681b      	ldr	r3, [r3, #0]
 8000fc6:	2b00      	cmp	r3, #0
 8000fc8:	d00b      	beq.n	8000fe2 <xTaskIncrementTick+0x4a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8000fca:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8000fce:	f383 8811 	msr	BASEPRI, r3
 8000fd2:	f3bf 8f6f 	isb	sy
 8000fd6:	f3bf 8f4f 	dsb	sy
 8000fda:	603b      	str	r3, [r7, #0]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
 8000fdc:	bf00      	nop
 8000fde:	bf00      	nop
 8000fe0:	e7fd      	b.n	8000fde <xTaskIncrementTick+0x46>
 8000fe2:	4b41      	ldr	r3, [pc, #260]	@ (80010e8 <xTaskIncrementTick+0x150>)
 8000fe4:	681b      	ldr	r3, [r3, #0]
 8000fe6:	60fb      	str	r3, [r7, #12]
 8000fe8:	4b40      	ldr	r3, [pc, #256]	@ (80010ec <xTaskIncrementTick+0x154>)
 8000fea:	681b      	ldr	r3, [r3, #0]
 8000fec:	4a3e      	ldr	r2, [pc, #248]	@ (80010e8 <xTaskIncrementTick+0x150>)
 8000fee:	6013      	str	r3, [r2, #0]
 8000ff0:	4a3e      	ldr	r2, [pc, #248]	@ (80010ec <xTaskIncrementTick+0x154>)
 8000ff2:	68fb      	ldr	r3, [r7, #12]
 8000ff4:	6013      	str	r3, [r2, #0]
 8000ff6:	4b3e      	ldr	r3, [pc, #248]	@ (80010f0 <xTaskIncrementTick+0x158>)
 8000ff8:	681b      	ldr	r3, [r3, #0]
 8000ffa:	3301      	adds	r3, #1
 8000ffc:	4a3c      	ldr	r2, [pc, #240]	@ (80010f0 <xTaskIncrementTick+0x158>)
 8000ffe:	6013      	str	r3, [r2, #0]
 8001000:	f000 f8e0 	bl	80011c4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001004:	4b3b      	ldr	r3, [pc, #236]	@ (80010f4 <xTaskIncrementTick+0x15c>)
 8001006:	681b      	ldr	r3, [r3, #0]
 8001008:	693a      	ldr	r2, [r7, #16]
 800100a:	429a      	cmp	r2, r3
 800100c:	d348      	bcc.n	80010a0 <xTaskIncrementTick+0x108>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800100e:	4b36      	ldr	r3, [pc, #216]	@ (80010e8 <xTaskIncrementTick+0x150>)
 8001010:	681b      	ldr	r3, [r3, #0]
 8001012:	681b      	ldr	r3, [r3, #0]
 8001014:	2b00      	cmp	r3, #0
 8001016:	d104      	bne.n	8001022 <xTaskIncrementTick+0x8a>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001018:	4b36      	ldr	r3, [pc, #216]	@ (80010f4 <xTaskIncrementTick+0x15c>)
 800101a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800101e:	601a      	str	r2, [r3, #0]
					break;
 8001020:	e03e      	b.n	80010a0 <xTaskIncrementTick+0x108>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001022:	4b31      	ldr	r3, [pc, #196]	@ (80010e8 <xTaskIncrementTick+0x150>)
 8001024:	681b      	ldr	r3, [r3, #0]
 8001026:	68db      	ldr	r3, [r3, #12]
 8001028:	68db      	ldr	r3, [r3, #12]
 800102a:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800102c:	68bb      	ldr	r3, [r7, #8]
 800102e:	685b      	ldr	r3, [r3, #4]
 8001030:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 8001032:	693a      	ldr	r2, [r7, #16]
 8001034:	687b      	ldr	r3, [r7, #4]
 8001036:	429a      	cmp	r2, r3
 8001038:	d203      	bcs.n	8001042 <xTaskIncrementTick+0xaa>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 800103a:	4a2e      	ldr	r2, [pc, #184]	@ (80010f4 <xTaskIncrementTick+0x15c>)
 800103c:	687b      	ldr	r3, [r7, #4]
 800103e:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8001040:	e02e      	b.n	80010a0 <xTaskIncrementTick+0x108>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001042:	68bb      	ldr	r3, [r7, #8]
 8001044:	3304      	adds	r3, #4
 8001046:	4618      	mov	r0, r3
 8001048:	f7ff ff7d 	bl	8000f46 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800104c:	68bb      	ldr	r3, [r7, #8]
 800104e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001050:	2b00      	cmp	r3, #0
 8001052:	d004      	beq.n	800105e <xTaskIncrementTick+0xc6>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001054:	68bb      	ldr	r3, [r7, #8]
 8001056:	3318      	adds	r3, #24
 8001058:	4618      	mov	r0, r3
 800105a:	f7ff ff74 	bl	8000f46 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 800105e:	68bb      	ldr	r3, [r7, #8]
 8001060:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001062:	2201      	movs	r2, #1
 8001064:	409a      	lsls	r2, r3
 8001066:	4b24      	ldr	r3, [pc, #144]	@ (80010f8 <xTaskIncrementTick+0x160>)
 8001068:	681b      	ldr	r3, [r3, #0]
 800106a:	4313      	orrs	r3, r2
 800106c:	4a22      	ldr	r2, [pc, #136]	@ (80010f8 <xTaskIncrementTick+0x160>)
 800106e:	6013      	str	r3, [r2, #0]
 8001070:	68bb      	ldr	r3, [r7, #8]
 8001072:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8001074:	4613      	mov	r3, r2
 8001076:	009b      	lsls	r3, r3, #2
 8001078:	4413      	add	r3, r2
 800107a:	009b      	lsls	r3, r3, #2
 800107c:	4a1f      	ldr	r2, [pc, #124]	@ (80010fc <xTaskIncrementTick+0x164>)
 800107e:	441a      	add	r2, r3
 8001080:	68bb      	ldr	r3, [r7, #8]
 8001082:	3304      	adds	r3, #4
 8001084:	4619      	mov	r1, r3
 8001086:	4610      	mov	r0, r2
 8001088:	f7ff ff3a 	bl	8000f00 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800108c:	68bb      	ldr	r3, [r7, #8]
 800108e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8001090:	4b1b      	ldr	r3, [pc, #108]	@ (8001100 <xTaskIncrementTick+0x168>)
 8001092:	681b      	ldr	r3, [r3, #0]
 8001094:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001096:	429a      	cmp	r2, r3
 8001098:	d3b9      	bcc.n	800100e <xTaskIncrementTick+0x76>
						{
							xSwitchRequired = pdTRUE;
 800109a:	2301      	movs	r3, #1
 800109c:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800109e:	e7b6      	b.n	800100e <xTaskIncrementTick+0x76>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80010a0:	4b17      	ldr	r3, [pc, #92]	@ (8001100 <xTaskIncrementTick+0x168>)
 80010a2:	681b      	ldr	r3, [r3, #0]
 80010a4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80010a6:	4915      	ldr	r1, [pc, #84]	@ (80010fc <xTaskIncrementTick+0x164>)
 80010a8:	4613      	mov	r3, r2
 80010aa:	009b      	lsls	r3, r3, #2
 80010ac:	4413      	add	r3, r2
 80010ae:	009b      	lsls	r3, r3, #2
 80010b0:	440b      	add	r3, r1
 80010b2:	681b      	ldr	r3, [r3, #0]
 80010b4:	2b01      	cmp	r3, #1
 80010b6:	d901      	bls.n	80010bc <xTaskIncrementTick+0x124>
			{
				xSwitchRequired = pdTRUE;
 80010b8:	2301      	movs	r3, #1
 80010ba:	617b      	str	r3, [r7, #20]
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 80010bc:	4b11      	ldr	r3, [pc, #68]	@ (8001104 <xTaskIncrementTick+0x16c>)
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	2b00      	cmp	r3, #0
 80010c2:	d007      	beq.n	80010d4 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
 80010c4:	2301      	movs	r3, #1
 80010c6:	617b      	str	r3, [r7, #20]
 80010c8:	e004      	b.n	80010d4 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 80010ca:	4b0f      	ldr	r3, [pc, #60]	@ (8001108 <xTaskIncrementTick+0x170>)
 80010cc:	681b      	ldr	r3, [r3, #0]
 80010ce:	3301      	adds	r3, #1
 80010d0:	4a0d      	ldr	r2, [pc, #52]	@ (8001108 <xTaskIncrementTick+0x170>)
 80010d2:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 80010d4:	697b      	ldr	r3, [r7, #20]
}
 80010d6:	4618      	mov	r0, r3
 80010d8:	3718      	adds	r7, #24
 80010da:	46bd      	mov	sp, r7
 80010dc:	bd80      	pop	{r7, pc}
 80010de:	bf00      	nop
 80010e0:	20000118 	.word	0x20000118
 80010e4:	200000fc 	.word	0x200000fc
 80010e8:	200000f4 	.word	0x200000f4
 80010ec:	200000f8 	.word	0x200000f8
 80010f0:	20000110 	.word	0x20000110
 80010f4:	20000114 	.word	0x20000114
 80010f8:	20000100 	.word	0x20000100
 80010fc:	20000068 	.word	0x20000068
 8001100:	20000064 	.word	0x20000064
 8001104:	2000010c 	.word	0x2000010c
 8001108:	20000108 	.word	0x20000108

0800110c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800110c:	b480      	push	{r7}
 800110e:	b087      	sub	sp, #28
 8001110:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001112:	4b27      	ldr	r3, [pc, #156]	@ (80011b0 <vTaskSwitchContext+0xa4>)
 8001114:	681b      	ldr	r3, [r3, #0]
 8001116:	2b00      	cmp	r3, #0
 8001118:	d003      	beq.n	8001122 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 800111a:	4b26      	ldr	r3, [pc, #152]	@ (80011b4 <vTaskSwitchContext+0xa8>)
 800111c:	2201      	movs	r2, #1
 800111e:	601a      	str	r2, [r3, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8001120:	e040      	b.n	80011a4 <vTaskSwitchContext+0x98>
		xYieldPending = pdFALSE;
 8001122:	4b24      	ldr	r3, [pc, #144]	@ (80011b4 <vTaskSwitchContext+0xa8>)
 8001124:	2200      	movs	r2, #0
 8001126:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001128:	4b23      	ldr	r3, [pc, #140]	@ (80011b8 <vTaskSwitchContext+0xac>)
 800112a:	681b      	ldr	r3, [r3, #0]
 800112c:	60fb      	str	r3, [r7, #12]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 800112e:	68fb      	ldr	r3, [r7, #12]
 8001130:	fab3 f383 	clz	r3, r3
 8001134:	72fb      	strb	r3, [r7, #11]
		return ucReturn;
 8001136:	7afb      	ldrb	r3, [r7, #11]
 8001138:	f1c3 031f 	rsb	r3, r3, #31
 800113c:	617b      	str	r3, [r7, #20]
 800113e:	491f      	ldr	r1, [pc, #124]	@ (80011bc <vTaskSwitchContext+0xb0>)
 8001140:	697a      	ldr	r2, [r7, #20]
 8001142:	4613      	mov	r3, r2
 8001144:	009b      	lsls	r3, r3, #2
 8001146:	4413      	add	r3, r2
 8001148:	009b      	lsls	r3, r3, #2
 800114a:	440b      	add	r3, r1
 800114c:	681b      	ldr	r3, [r3, #0]
 800114e:	2b00      	cmp	r3, #0
 8001150:	d10b      	bne.n	800116a <vTaskSwitchContext+0x5e>
	__asm volatile
 8001152:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8001156:	f383 8811 	msr	BASEPRI, r3
 800115a:	f3bf 8f6f 	isb	sy
 800115e:	f3bf 8f4f 	dsb	sy
 8001162:	607b      	str	r3, [r7, #4]
}
 8001164:	bf00      	nop
 8001166:	bf00      	nop
 8001168:	e7fd      	b.n	8001166 <vTaskSwitchContext+0x5a>
 800116a:	697a      	ldr	r2, [r7, #20]
 800116c:	4613      	mov	r3, r2
 800116e:	009b      	lsls	r3, r3, #2
 8001170:	4413      	add	r3, r2
 8001172:	009b      	lsls	r3, r3, #2
 8001174:	4a11      	ldr	r2, [pc, #68]	@ (80011bc <vTaskSwitchContext+0xb0>)
 8001176:	4413      	add	r3, r2
 8001178:	613b      	str	r3, [r7, #16]
 800117a:	693b      	ldr	r3, [r7, #16]
 800117c:	685b      	ldr	r3, [r3, #4]
 800117e:	685a      	ldr	r2, [r3, #4]
 8001180:	693b      	ldr	r3, [r7, #16]
 8001182:	605a      	str	r2, [r3, #4]
 8001184:	693b      	ldr	r3, [r7, #16]
 8001186:	685a      	ldr	r2, [r3, #4]
 8001188:	693b      	ldr	r3, [r7, #16]
 800118a:	3308      	adds	r3, #8
 800118c:	429a      	cmp	r2, r3
 800118e:	d104      	bne.n	800119a <vTaskSwitchContext+0x8e>
 8001190:	693b      	ldr	r3, [r7, #16]
 8001192:	685b      	ldr	r3, [r3, #4]
 8001194:	685a      	ldr	r2, [r3, #4]
 8001196:	693b      	ldr	r3, [r7, #16]
 8001198:	605a      	str	r2, [r3, #4]
 800119a:	693b      	ldr	r3, [r7, #16]
 800119c:	685b      	ldr	r3, [r3, #4]
 800119e:	68db      	ldr	r3, [r3, #12]
 80011a0:	4a07      	ldr	r2, [pc, #28]	@ (80011c0 <vTaskSwitchContext+0xb4>)
 80011a2:	6013      	str	r3, [r2, #0]
}
 80011a4:	bf00      	nop
 80011a6:	371c      	adds	r7, #28
 80011a8:	46bd      	mov	sp, r7
 80011aa:	bc80      	pop	{r7}
 80011ac:	4770      	bx	lr
 80011ae:	bf00      	nop
 80011b0:	20000118 	.word	0x20000118
 80011b4:	2000010c 	.word	0x2000010c
 80011b8:	20000100 	.word	0x20000100
 80011bc:	20000068 	.word	0x20000068
 80011c0:	20000064 	.word	0x20000064

080011c4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 80011c4:	b480      	push	{r7}
 80011c6:	b083      	sub	sp, #12
 80011c8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80011ca:	4b0c      	ldr	r3, [pc, #48]	@ (80011fc <prvResetNextTaskUnblockTime+0x38>)
 80011cc:	681b      	ldr	r3, [r3, #0]
 80011ce:	681b      	ldr	r3, [r3, #0]
 80011d0:	2b00      	cmp	r3, #0
 80011d2:	d104      	bne.n	80011de <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80011d4:	4b0a      	ldr	r3, [pc, #40]	@ (8001200 <prvResetNextTaskUnblockTime+0x3c>)
 80011d6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80011da:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 80011dc:	e008      	b.n	80011f0 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80011de:	4b07      	ldr	r3, [pc, #28]	@ (80011fc <prvResetNextTaskUnblockTime+0x38>)
 80011e0:	681b      	ldr	r3, [r3, #0]
 80011e2:	68db      	ldr	r3, [r3, #12]
 80011e4:	68db      	ldr	r3, [r3, #12]
 80011e6:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80011e8:	687b      	ldr	r3, [r7, #4]
 80011ea:	685b      	ldr	r3, [r3, #4]
 80011ec:	4a04      	ldr	r2, [pc, #16]	@ (8001200 <prvResetNextTaskUnblockTime+0x3c>)
 80011ee:	6013      	str	r3, [r2, #0]
}
 80011f0:	bf00      	nop
 80011f2:	370c      	adds	r7, #12
 80011f4:	46bd      	mov	sp, r7
 80011f6:	bc80      	pop	{r7}
 80011f8:	4770      	bx	lr
 80011fa:	bf00      	nop
 80011fc:	200000f4 	.word	0x200000f4
 8001200:	20000114 	.word	0x20000114

08001204 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 8001204:	b480      	push	{r7}
 8001206:	b083      	sub	sp, #12
 8001208:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 800120a:	4b0b      	ldr	r3, [pc, #44]	@ (8001238 <xTaskGetSchedulerState+0x34>)
 800120c:	681b      	ldr	r3, [r3, #0]
 800120e:	2b00      	cmp	r3, #0
 8001210:	d102      	bne.n	8001218 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 8001212:	2301      	movs	r3, #1
 8001214:	607b      	str	r3, [r7, #4]
 8001216:	e008      	b.n	800122a <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001218:	4b08      	ldr	r3, [pc, #32]	@ (800123c <xTaskGetSchedulerState+0x38>)
 800121a:	681b      	ldr	r3, [r3, #0]
 800121c:	2b00      	cmp	r3, #0
 800121e:	d102      	bne.n	8001226 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 8001220:	2302      	movs	r3, #2
 8001222:	607b      	str	r3, [r7, #4]
 8001224:	e001      	b.n	800122a <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 8001226:	2300      	movs	r3, #0
 8001228:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 800122a:	687b      	ldr	r3, [r7, #4]
	}
 800122c:	4618      	mov	r0, r3
 800122e:	370c      	adds	r7, #12
 8001230:	46bd      	mov	sp, r7
 8001232:	bc80      	pop	{r7}
 8001234:	4770      	bx	lr
 8001236:	bf00      	nop
 8001238:	20000104 	.word	0x20000104
 800123c:	20000118 	.word	0x20000118

08001240 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8001240:	4b07      	ldr	r3, [pc, #28]	@ (8001260 <pxCurrentTCBConst2>)
 8001242:	6819      	ldr	r1, [r3, #0]
 8001244:	6808      	ldr	r0, [r1, #0]
 8001246:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800124a:	f380 8809 	msr	PSP, r0
 800124e:	f3bf 8f6f 	isb	sy
 8001252:	f04f 0000 	mov.w	r0, #0
 8001256:	f380 8811 	msr	BASEPRI, r0
 800125a:	f04e 0e0d 	orr.w	lr, lr, #13
 800125e:	4770      	bx	lr

08001260 <pxCurrentTCBConst2>:
 8001260:	20000064 	.word	0x20000064
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 8001264:	bf00      	nop
 8001266:	bf00      	nop
	...

08001270 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001270:	f3ef 8009 	mrs	r0, PSP
 8001274:	f3bf 8f6f 	isb	sy
 8001278:	4b0d      	ldr	r3, [pc, #52]	@ (80012b0 <pxCurrentTCBConst>)
 800127a:	681a      	ldr	r2, [r3, #0]
 800127c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001280:	6010      	str	r0, [r2, #0]
 8001282:	e92d 4008 	stmdb	sp!, {r3, lr}
 8001286:	f04f 0050 	mov.w	r0, #80	@ 0x50
 800128a:	f380 8811 	msr	BASEPRI, r0
 800128e:	f7ff ff3d 	bl	800110c <vTaskSwitchContext>
 8001292:	f04f 0000 	mov.w	r0, #0
 8001296:	f380 8811 	msr	BASEPRI, r0
 800129a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800129e:	6819      	ldr	r1, [r3, #0]
 80012a0:	6808      	ldr	r0, [r1, #0]
 80012a2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80012a6:	f380 8809 	msr	PSP, r0
 80012aa:	f3bf 8f6f 	isb	sy
 80012ae:	4770      	bx	lr

080012b0 <pxCurrentTCBConst>:
 80012b0:	20000064 	.word	0x20000064
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 80012b4:	bf00      	nop
 80012b6:	bf00      	nop

080012b8 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80012b8:	b580      	push	{r7, lr}
 80012ba:	b082      	sub	sp, #8
 80012bc:	af00      	add	r7, sp, #0
	__asm volatile
 80012be:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80012c2:	f383 8811 	msr	BASEPRI, r3
 80012c6:	f3bf 8f6f 	isb	sy
 80012ca:	f3bf 8f4f 	dsb	sy
 80012ce:	607b      	str	r3, [r7, #4]
}
 80012d0:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80012d2:	f7ff fe61 	bl	8000f98 <xTaskIncrementTick>
 80012d6:	4603      	mov	r3, r0
 80012d8:	2b00      	cmp	r3, #0
 80012da:	d003      	beq.n	80012e4 <xPortSysTickHandler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80012dc:	4b06      	ldr	r3, [pc, #24]	@ (80012f8 <xPortSysTickHandler+0x40>)
 80012de:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80012e2:	601a      	str	r2, [r3, #0]
 80012e4:	2300      	movs	r3, #0
 80012e6:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80012e8:	683b      	ldr	r3, [r7, #0]
 80012ea:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
 80012ee:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
 80012f0:	bf00      	nop
 80012f2:	3708      	adds	r7, #8
 80012f4:	46bd      	mov	sp, r7
 80012f6:	bd80      	pop	{r7, pc}
 80012f8:	e000ed04 	.word	0xe000ed04

080012fc <__libc_init_array>:
 80012fc:	b570      	push	{r4, r5, r6, lr}
 80012fe:	2600      	movs	r6, #0
 8001300:	4d0c      	ldr	r5, [pc, #48]	@ (8001334 <__libc_init_array+0x38>)
 8001302:	4c0d      	ldr	r4, [pc, #52]	@ (8001338 <__libc_init_array+0x3c>)
 8001304:	1b64      	subs	r4, r4, r5
 8001306:	10a4      	asrs	r4, r4, #2
 8001308:	42a6      	cmp	r6, r4
 800130a:	d109      	bne.n	8001320 <__libc_init_array+0x24>
 800130c:	f000 f81a 	bl	8001344 <_init>
 8001310:	2600      	movs	r6, #0
 8001312:	4d0a      	ldr	r5, [pc, #40]	@ (800133c <__libc_init_array+0x40>)
 8001314:	4c0a      	ldr	r4, [pc, #40]	@ (8001340 <__libc_init_array+0x44>)
 8001316:	1b64      	subs	r4, r4, r5
 8001318:	10a4      	asrs	r4, r4, #2
 800131a:	42a6      	cmp	r6, r4
 800131c:	d105      	bne.n	800132a <__libc_init_array+0x2e>
 800131e:	bd70      	pop	{r4, r5, r6, pc}
 8001320:	f855 3b04 	ldr.w	r3, [r5], #4
 8001324:	4798      	blx	r3
 8001326:	3601      	adds	r6, #1
 8001328:	e7ee      	b.n	8001308 <__libc_init_array+0xc>
 800132a:	f855 3b04 	ldr.w	r3, [r5], #4
 800132e:	4798      	blx	r3
 8001330:	3601      	adds	r6, #1
 8001332:	e7f2      	b.n	800131a <__libc_init_array+0x1e>
 8001334:	0800135c 	.word	0x0800135c
 8001338:	0800135c 	.word	0x0800135c
 800133c:	0800135c 	.word	0x0800135c
 8001340:	08001360 	.word	0x08001360

08001344 <_init>:
 8001344:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001346:	bf00      	nop
 8001348:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800134a:	bc08      	pop	{r3}
 800134c:	469e      	mov	lr, r3
 800134e:	4770      	bx	lr

08001350 <_fini>:
 8001350:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001352:	bf00      	nop
 8001354:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001356:	bc08      	pop	{r3}
 8001358:	469e      	mov	lr, r3
 800135a:	4770      	bx	lr
